{
  "language": "Solidity",
  "sources": {
    "contracts/Admin.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IncentiveDistribution.sol\";\nimport \"./RoleAware.sol\";\nimport \"./Fund.sol\";\nimport \"./CrossMarginTrading.sol\";\n\ncontract Admin is RoleAware, Ownable {\n    address MFI;\n    mapping(address => uint256) public stakes;\n    uint256 public totalStakes;\n    mapping(address => uint256) public claimIds;\n\n    uint256 feesPer10k;\n    mapping(address => uint256) public collectedFees;\n\n    uint256 public maintenanceStakePerBlock = 10 ether;\n    mapping(address => address) public nextMaintenanceStaker;\n    mapping(address => mapping(address => bool)) public maintenanceDelegateTo;\n    address public currentMaintenanceStaker;\n    address public prevMaintenanceStaker;\n    uint256 public currentMaintenanceStakerStartBlock;\n    address public lockedMFI;\n\n    constructor(\n        uint256 _feesPer10k,\n        address _MFI,\n        address _lockedMFI,\n        address lockedMFIDelegate,\n        address _roles\n    ) RoleAware(_roles) Ownable() {\n        MFI = _MFI;\n        feesPer10k = _feesPer10k;\n        maintenanceStakePerBlock = 1 ether;\n        lockedMFI = _lockedMFI;\n\n        // for initialization purposes and to ensure availability of service\n        // the team's locked MFI participate in maintenance staking only\n        // (not in the incentive staking part)\n        // this implies some trust of the team to execute, which we deem reasonable\n        // since the locked stake is temporary and diminishing as well as the fact\n        // that the team is heavily invested in the protocol and incentivized\n        // by fees like any other maintainer\n        // furthermore others could step in to liquidate via the attacker route\n        // and take away the team fees if they were delinquent\n        nextMaintenanceStaker[lockedMFI] = lockedMFI;\n        currentMaintenanceStaker = lockedMFI;\n        prevMaintenanceStaker = lockedMFI;\n        maintenanceDelegateTo[lockedMFI][lockedMFIDelegate];\n        currentMaintenanceStakerStartBlock = block.number;\n    }\n\n    function setMaintenanceStakePerBlock(uint256 amount) external onlyOwner {\n        maintenanceStakePerBlock = amount;\n    }\n\n    function _stake(address holder, uint256 amount) internal {\n        require(\n            Fund(fund()).depositFor(holder, MFI, amount),\n            \"Could not deposit stake funds (perhaps make allowance to fund contract?\"\n        );\n        stakes[holder] += amount;\n        totalStakes += amount;\n\n        if (claimIds[holder] > 0) {\n            IncentiveDistribution(incentiveDistributor()).addToClaimAmount(\n                0,\n                claimIds[holder],\n                amount\n            );\n        } else {\n            uint256 claimId =\n                IncentiveDistribution(incentiveDistributor()).startClaim(\n                    0,\n                    holder,\n                    amount\n                );\n            claimIds[holder] = claimId;\n            require(claimId > 0, \"Distribution is over or paused\");\n        }\n    }\n\n    function depositStake(uint256 amount) external {\n        _stake(msg.sender, amount);\n    }\n\n    function _withdrawStake(\n        address holder,\n        uint256 amount,\n        address recipient\n    ) internal {\n        uint256 stakeAmount = stakes[holder];\n        // overflow failure desirable\n        stakes[holder] = amount;\n        totalStakes -= amount;\n        require(\n            Fund(fund()).withdraw(MFI, recipient, amount),\n            \"Insufficient funds -- something went really wrong.\"\n        );\n        if (stakeAmount == amount) {\n            IncentiveDistribution(incentiveDistributor()).endClaim(\n                0,\n                claimIds[holder]\n            );\n            claimIds[holder] = 0;\n        } else {\n            IncentiveDistribution(incentiveDistributor())\n                .subtractFromClaimAmount(0, claimIds[holder], amount);\n        }\n    }\n\n    function withdrawStake(uint256 amount) external {\n        require(\n            !isAuthorizedStaker(msg.sender),\n            \"You can't withdraw while you're authorized staker\"\n        );\n        _withdrawStake(msg.sender, amount, msg.sender);\n    }\n\n    function addTradingFees(address token, uint256 amount)\n        external\n        returns (uint256 fees)\n    {\n        require(isFeeSource(msg.sender), \"Not authorized to source fees\");\n        fees = (feesPer10k * amount) / 10_000;\n        collectedFees[token] += fees;\n    }\n\n    function subtractTradingFees(address token, uint256 amount)\n        external\n        returns (uint256 fees)\n    {\n        require(isFeeSource(msg.sender), \"Not authorized to source fees\");\n        fees = (feesPer10k * amount) / (10_000 + feesPer10k);\n        collectedFees[token] += fees;\n    }\n\n    function depositMaintenanceStake(uint256 amount) external {\n        require(\n            amount + stakes[msg.sender] >= maintenanceStakePerBlock,\n            \"Insufficient stake to call even one block\"\n        );\n        _stake(msg.sender, amount);\n        if (nextMaintenanceStaker[msg.sender] == address(0)) {\n            nextMaintenanceStaker[msg.sender] = getUpdatedCurrentStaker();\n            nextMaintenanceStaker[prevMaintenanceStaker] = msg.sender;\n        }\n    }\n\n    function getMaintenanceStakerStake(address staker)\n        public\n        view\n        returns (uint256)\n    {\n        if (staker == lockedMFI) {\n            return IERC20(MFI).balanceOf(lockedMFI) / 2;\n        } else {\n            return stakes[staker];\n        }\n    }\n\n    function getUpdatedCurrentStaker() public returns (address) {\n        uint256 currentStake =\n            getMaintenanceStakerStake(currentMaintenanceStaker);\n        while (\n            (block.number - currentMaintenanceStakerStartBlock) *\n                maintenanceStakePerBlock >=\n            currentStake\n        ) {\n            if (maintenanceStakePerBlock > currentStake) {\n                // delete current from daisy chain\n                address nextOne =\n                    nextMaintenanceStaker[currentMaintenanceStaker];\n                nextMaintenanceStaker[prevMaintenanceStaker] = nextOne;\n                nextMaintenanceStaker[currentMaintenanceStaker] = address(0);\n\n                currentMaintenanceStaker = nextOne;\n            } else {\n                currentMaintenanceStakerStartBlock +=\n                    stakes[currentMaintenanceStaker] /\n                    maintenanceStakePerBlock;\n\n                prevMaintenanceStaker = currentMaintenanceStaker;\n                currentMaintenanceStaker = nextMaintenanceStaker[\n                    currentMaintenanceStaker\n                ];\n            }\n            currentStake = getMaintenanceStakerStake(currentMaintenanceStaker);\n        }\n        return currentMaintenanceStaker;\n    }\n\n    function viewCurrentMaintenanceStaker()\n        public\n        view\n        returns (address staker, uint256 startBlock)\n    {\n        staker = currentMaintenanceStaker;\n        uint256 currentStake = getMaintenanceStakerStake(staker);\n        startBlock = currentMaintenanceStakerStartBlock;\n        while (\n            (block.number - startBlock) * maintenanceStakePerBlock >=\n            currentStake\n        ) {\n            if (maintenanceStakePerBlock > currentStake) {\n                // skip\n                staker = nextMaintenanceStaker[staker];\n                currentStake = getMaintenanceStakerStake(staker);\n            } else {\n                startBlock +=\n                    stakes[currentMaintenanceStaker] /\n                    maintenanceStakePerBlock;\n                staker = nextMaintenanceStaker[staker];\n                currentStake = getMaintenanceStakerStake(staker);\n            }\n        }\n    }\n\n    function addDelegate(address forStaker, address delegate) external {\n        require(\n            msg.sender == forStaker ||\n                maintenanceDelegateTo[forStaker][msg.sender],\n            \"msg.sender not authorized to delegate for staker\"\n        );\n        maintenanceDelegateTo[forStaker][delegate] = true;\n    }\n\n    function removeDelegate(address forStaker, address delegate) external {\n        require(\n            msg.sender == forStaker ||\n                maintenanceDelegateTo[forStaker][msg.sender],\n            \"msg.sender not authorized to delegate for staker\"\n        );\n        maintenanceDelegateTo[forStaker][delegate] = false;\n    }\n\n    function isAuthorizedStaker(address caller)\n        public\n        returns (bool isAuthorized)\n    {\n        address currentStaker = getUpdatedCurrentStaker();\n        isAuthorized =\n            currentStaker == caller ||\n            maintenanceDelegateTo[currentStaker][caller];\n    }\n\n    function penalizeMaintenanceStake(\n        address maintainer,\n        uint256 penalty,\n        address recipient\n    ) external returns (uint256 stakeTaken) {\n        require(\n            isStakePenalizer(msg.sender),\n            \"msg.sender not authorized to penalize stakers\"\n        );\n        if (penalty > stakes[maintainer]) {\n            stakeTaken = stakes[maintainer];\n        } else {\n            stakeTaken = penalty;\n        }\n        _withdrawStake(maintainer, stakeTaken, recipient);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/IncentiveDistribution.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./RoleAware.sol\";\nimport \"./Fund.sol\";\n\nstruct Claim {\n    uint256 startingRewardRateFP;\n    address recipient;\n    uint256 amount;\n}\n\ncontract IncentiveDistribution is RoleAware, Ownable {\n    // fixed point number factor\n    uint256 constant FP32 = 2**32;\n    // the amount of contraction per thousand, per day\n    // of the overal daily incentive distribution\n    uint256 constant contractionPerMil = 999;\n    // the period for which claims are batch updated\n    uint256 constant period = 4 hours;\n    uint256 constant periodsPerDay = 24 hours / period;\n    address MFI;\n\n    constructor(\n        address _MFI,\n        uint256 startingDailyDistributionWithoutDecimals,\n        address _roles\n    ) RoleAware(_roles) Ownable() {\n        MFI = _MFI;\n        currentDailyDistribution =\n            startingDailyDistributionWithoutDecimals *\n            (1 ether);\n        lastDailyDistributionUpdate = block.timestamp / (1 days);\n    }\n\n    // how much is going to be distributed, contracts every day\n    uint256 public currentDailyDistribution;\n    // last day on which we updated currentDailyDistribution\n    uint256 lastDailyDistributionUpdate;\n    // portion of daily distribution per each tranche\n    mapping(uint8 => uint256) public trancheShare;\n    uint256 public trancheShareTotal;\n\n    // tranche => claim totals for the period we're currently aggregating\n    mapping(uint8 => uint256) public currentPeriodTotals;\n    // tranche => timestamp / period of last update\n    mapping(uint8 => uint256) public lastUpdatedPeriods;\n\n    // how each claim unit would get if they had staked from the dawn of time\n    // expressed as fixed point number\n    // claim amounts are expressed relative to this ongoing aggregate\n    mapping(uint8 => uint256) public aggregatePeriodicRewardRateFP;\n    // claim records\n    mapping(uint256 => Claim) public claims;\n    uint256 public nextClaimId = 1;\n\n    function setTrancheShare(uint8 tranche, uint256 share) external onlyOwner {\n        require(\n            lastUpdatedPeriods[tranche] > 0,\n            \"Tranche is not initialized, please initialize first\"\n        );\n        _setTrancheShare(tranche, share);\n    }\n\n    function _setTrancheShare(uint8 tranche, uint256 share) internal {\n        if (share > trancheShare[tranche]) {\n            trancheShareTotal += share - trancheShare[tranche];\n        } else {\n            trancheShareTotal -= trancheShare[tranche] - share;\n        }\n        trancheShare[tranche] = share;\n    }\n\n    function initTranche(uint8 tranche, uint256 share) external onlyOwner {\n        _setTrancheShare(tranche, share);\n\n        lastUpdatedPeriods[tranche] = block.timestamp / period;\n        // simply initialize to 1.0\n        aggregatePeriodicRewardRateFP[tranche] = FP32;\n    }\n\n    function updatePeriodTotals(uint8 tranche) internal {\n        uint256 currentPeriod = block.timestamp / period;\n\n        // update the amount that gets distributed per day, if there has been\n        // a day transition\n        updateCurrentDailyDistribution();\n        // Do a bunch of updating of periodic variables when the period changes\n        uint256 lU = lastUpdatedPeriods[tranche];\n        uint256 periodDiff = currentPeriod - lU;\n\n        if (periodDiff > 0) {\n            aggregatePeriodicRewardRateFP[tranche] +=\n                currentPeriodicRewardRateFP(tranche) *\n                periodDiff;\n        }\n\n        lastUpdatedPeriods[tranche] = currentPeriod;\n    }\n\n    function forcePeriodTotalUpdate(uint8 tranche) external {\n        updatePeriodTotals(tranche);\n    }\n\n    function updateCurrentDailyDistribution() internal {\n        uint256 nowDay = block.timestamp / (1 days);\n        uint256 dayDiff = nowDay - lastDailyDistributionUpdate;\n\n        // shrink the daily distribution for every day that has passed\n        for (uint256 i = 0; i < dayDiff; i++) {\n            currentDailyDistribution =\n                (currentDailyDistribution * contractionPerMil) /\n                1000;\n        }\n        // now update this memo\n        lastDailyDistributionUpdate = nowDay;\n    }\n\n    function currentPeriodicRewardRateFP(uint8 tranche)\n        internal\n        view\n        returns (uint256)\n    {\n        // scale daily distribution down to tranche share\n        uint256 tranchePeriodDistributionFP =\n            (FP32 * currentDailyDistribution * trancheShare[tranche]) /\n                trancheShareTotal /\n                periodsPerDay;\n\n        // rate = (total_reward / total_claims) per period\n        return tranchePeriodDistributionFP / currentPeriodTotals[tranche];\n    }\n\n    function startClaim(\n        uint8 tranche,\n        address recipient,\n        uint256 claimAmount\n    ) external returns (uint256) {\n        require(\n            isIncentiveReporter(msg.sender),\n            \"Contract not authorized to report incentives\"\n        );\n        if (currentDailyDistribution > 0) {\n            updatePeriodTotals(tranche);\n\n            currentPeriodTotals[tranche] += claimAmount;\n\n            claims[nextClaimId] = Claim({\n                startingRewardRateFP: aggregatePeriodicRewardRateFP[tranche],\n                recipient: recipient,\n                amount: claimAmount\n            });\n            nextClaimId += 1;\n            return nextClaimId - 1;\n        } else {\n            return 0;\n        }\n    }\n\n    function addToClaimAmount(\n        uint8 tranche,\n        uint256 claimId,\n        uint256 additionalAmount\n    ) external {\n        require(\n            isIncentiveReporter(msg.sender),\n            \"Contract not authorized to report incentives\"\n        );\n        if (currentDailyDistribution > 0) {\n            updatePeriodTotals(tranche);\n\n            currentPeriodTotals[tranche] += additionalAmount;\n\n            Claim storage claim = claims[claimId];\n            require(\n                claim.startingRewardRateFP > 0,\n                \"Trying to add to non-existant claim\"\n            );\n            _withdrawReward(tranche, claim);\n            claim.amount += additionalAmount;\n        }\n    }\n\n    function subtractFromClaimAmount(\n        uint8 tranche,\n        uint256 claimId,\n        uint256 subtractAmount\n    ) external {\n        require(\n            isIncentiveReporter(msg.sender),\n            \"Contract not authorized to report incentives\"\n        );\n        updatePeriodTotals(tranche);\n\n        currentPeriodTotals[tranche] -= subtractAmount;\n\n        Claim storage claim = claims[claimId];\n        _withdrawReward((tranche), claim);\n        claim.amount -= subtractAmount;\n    }\n\n    function endClaim(uint8 tranche, uint256 claimId) external {\n        require(\n            isIncentiveReporter(msg.sender),\n            \"Contract not authorized to report incentives\"\n        );\n        updatePeriodTotals(tranche);\n        Claim storage claim = claims[claimId];\n\n        if (claim.startingRewardRateFP > 0) {\n            _withdrawReward(tranche, claim);\n            delete claim.recipient;\n            delete claim.startingRewardRateFP;\n            delete claim.amount;\n        }\n    }\n\n    function calcRewardAmount(uint8 tranche, Claim storage claim)\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            (claim.amount *\n                (aggregatePeriodicRewardRateFP[tranche] -\n                    claim.startingRewardRateFP)) / FP32;\n    }\n\n    function viewRewardAmount(uint8 tranche, uint256 claimId)\n        external\n        view\n        returns (uint256)\n    {\n        return calcRewardAmount(tranche, claims[claimId]);\n    }\n\n    function withdrawReward(uint8 tranche, uint256 claimId)\n        external\n        returns (uint256)\n    {\n        require(\n            isIncentiveReporter(msg.sender),\n            \"Contract not authorized to report incentives\"\n        );\n        updatePeriodTotals(tranche);\n        Claim storage claim = claims[claimId];\n        return _withdrawReward(tranche, claim);\n    }\n\n    function _withdrawReward(uint8 tranche, Claim storage claim)\n        internal\n        returns (uint256 rewardAmount)\n    {\n        rewardAmount = calcRewardAmount(tranche, claim);\n\n        require(\n            Fund(fund()).withdraw(MFI, claim.recipient, rewardAmount),\n            \"There seems to be a lack of MFI in the incentive fund!\"\n        );\n\n        claim.startingRewardRateFP = aggregatePeriodicRewardRateFP[tranche];\n    }\n}\n"
    },
    "contracts/RoleAware.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"./Roles.sol\";\n\ncontract RoleAware {\n    uint16 public constant WITHDRAWER = 1;\n    uint16 public constant MARGIN_CALLER = 2;\n    uint16 public constant BORROWER = 3;\n    uint16 public constant MARGIN_TRADER = 4;\n    uint16 public constant FEE_SOURCE = 5;\n    uint16 public constant LIQUIDATOR = 6;\n    uint16 public constant AUTHORIZED_FUND_TRADER = 7;\n    uint16 public constant INCENTIVE_REPORTER = 8;\n    uint16 public constant TOKEN_ACTIVATOR = 9;\n    uint16 public constant STAKE_PENALIZER = 10;\n\n    uint16 public constant FUND = 101;\n    uint16 public constant LENDING = 102;\n    uint16 public constant ROUTER = 103;\n    uint16 public constant MARGIN_TRADING = 104;\n    uint16 public constant FEE_CONTROLLER = 105;\n    uint16 public constant PRICE_CONTROLLER = 106;\n    uint16 public constant ADMIN = 107;\n    uint16 public constant INCENTIVE_DISTRIBUTION = 108;\n\n    Roles public roles;\n    mapping(uint16 => address) public mainCharacterCache;\n    mapping(address => mapping(uint16 => bool)) public roleCache;\n\n    constructor(address _roles) {\n        roles = Roles(_roles);\n    }\n\n    modifier noIntermediary() {\n        require(\n            msg.sender == tx.origin,\n            \"Currently no intermediaries allowed for this function call\"\n        );\n        _;\n    }\n\n    function updateRoleCache(uint16 role, address contr) public virtual {\n        roleCache[contr][role] = roles.getRole(role, contr);\n    }\n\n    function updateMainCharacterCache(uint16 role) public virtual {\n        mainCharacterCache[role] = roles.mainCharacters(role);\n    }\n\n    function fund() internal view returns (address) {\n        return mainCharacterCache[FUND];\n    }\n\n    function lending() internal view returns (address) {\n        return mainCharacterCache[LENDING];\n    }\n\n    function router() internal view returns (address) {\n        return mainCharacterCache[ROUTER];\n    }\n\n    function marginTrading() internal view returns (address) {\n        return mainCharacterCache[MARGIN_TRADING];\n    }\n\n    function feeController() internal view returns (address) {\n        return mainCharacterCache[FEE_CONTROLLER];\n    }\n\n    function price() internal view returns (address) {\n        return mainCharacterCache[PRICE_CONTROLLER];\n    }\n\n    function admin() internal view returns (address) {\n        return mainCharacterCache[ADMIN];\n    }\n\n    function incentiveDistributor() internal view returns (address) {\n        return mainCharacterCache[INCENTIVE_DISTRIBUTION];\n    }\n\n    function isBorrower(address contr) internal view returns (bool) {\n        return roleCache[contr][BORROWER];\n    }\n\n    function isWithdrawer(address contr) internal view returns (bool) {\n        return roleCache[contr][WITHDRAWER];\n    }\n\n    function isMarginTrader(address contr) internal view returns (bool) {\n        return roleCache[contr][MARGIN_TRADER];\n    }\n\n    function isFeeSource(address contr) internal view returns (bool) {\n        return roleCache[contr][FEE_SOURCE];\n    }\n\n    function isMarginCaller(address contr) internal view returns (bool) {\n        return roleCache[contr][MARGIN_CALLER];\n    }\n\n    function isLiquidator(address contr) internal view returns (bool) {\n        return roleCache[contr][LIQUIDATOR];\n    }\n\n    function isAuthorizedFundTrader(address contr)\n        internal\n        view\n        returns (bool)\n    {\n        return roleCache[contr][AUTHORIZED_FUND_TRADER];\n    }\n\n    function isIncentiveReporter(address contr) internal view returns (bool) {\n        return roleCache[contr][INCENTIVE_REPORTER];\n    }\n\n    function isTokenActivator(address contr) internal view returns (bool) {\n        return roleCache[contr][TOKEN_ACTIVATOR];\n    }\n\n    function isStakePenalizer(address contr) internal view returns (bool) {\n        return roles.getRole(STAKE_PENALIZER, contr);\n    }\n}\n"
    },
    "contracts/Fund.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"./RoleAware.sol\";\n\ncontract Fund is RoleAware, Ownable {\n    address public WETH;\n    mapping(address => bool) public activeTokens;\n\n    constructor(address _WETH, address _roles) Ownable() RoleAware(_roles) {\n        WETH = _WETH;\n    }\n\n    function activateToken(address token) external {\n        require(\n            isTokenActivator(msg.sender),\n            \"Address not authorized to activate tokens\"\n        );\n        activeTokens[token] = true;\n    }\n\n    function deactivateToken(address token) external {\n        require(\n            isTokenActivator(msg.sender),\n            \"Address not authorized to activate tokens\"\n        );\n        activeTokens[token] = false;\n    }\n\n    function deposit(address depositToken, uint256 depositAmount)\n        external\n        returns (bool)\n    {\n        require(activeTokens[depositToken], \"Deposit token is not active\");\n        return\n            IERC20(depositToken).transferFrom(\n                msg.sender,\n                address(this),\n                depositAmount\n            );\n    }\n\n    function depositFor(\n        address sender,\n        address depositToken,\n        uint256 depositAmount\n    ) external returns (bool) {\n        require(activeTokens[depositToken], \"Deposit token is not active\");\n        require(isWithdrawer(msg.sender), \"Contract not authorized to deposit\");\n        return\n            IERC20(depositToken).transferFrom(\n                sender,\n                address(this),\n                depositAmount\n            );\n    }\n\n    function depositToWETH() external payable {\n        IWETH(WETH).deposit{value: msg.value}();\n    }\n\n    // withdrawers role\n    function withdraw(\n        address withdrawalToken,\n        address recipient,\n        uint256 withdrawalAmount\n    ) external returns (bool) {\n        require(\n            isWithdrawer(msg.sender),\n            \"Contract not authorized to withdraw\"\n        );\n        return IERC20(withdrawalToken).transfer(recipient, withdrawalAmount);\n    }\n\n    // withdrawers role\n    function withdrawETH(address recipient, uint256 withdrawalAmount) external {\n        require(isWithdrawer(msg.sender), \"Not authorized to withdraw\");\n        IWETH(WETH).withdraw(withdrawalAmount);\n        payable(recipient).transfer(withdrawalAmount);\n    }\n}\n"
    },
    "contracts/CrossMarginTrading.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Fund.sol\";\nimport \"./Lending.sol\";\nimport \"./RoleAware.sol\";\nimport \"./MarginRouter.sol\";\nimport \"./CrossMarginLiquidation.sol\";\n\n// Goal: all external functions only accessible to margintrader role\n// except for view functions of course\n\ncontract CrossMarginTrading is CrossMarginLiquidation, IMarginTrading {\n    constructor(address _peg, address _roles)\n        RoleAware(_roles)\n        PriceAware(_peg)\n    {\n        liquidationThresholdPercent = 110;\n        coolingOffPeriod = 20;\n    }\n\n    /// @dev admin function to set the token cap\n    function setTokenCap(address token, uint256 cap) external {\n        require(\n            isTokenActivator(msg.sender),\n            \"Caller not authorized to set token cap\"\n        );\n        tokenCaps[token] = cap;\n    }\n\n    /// @dev setter for cooling off period for withdrawing funds after deposit\n    function setCoolingOffPeriod(uint256 blocks) external onlyOwner {\n        coolingOffPeriod = blocks;\n    }\n\n    /// @dev admin function to set leverage\n    function setLeverage(uint256 _leverage) external onlyOwner {\n        leverage = _leverage;\n    }\n\n    /// @dev admin function to set liquidation threshold\n    function setLiquidationThresholdPercent(uint256 threshold)\n        external\n        onlyOwner\n    {\n        liquidationThresholdPercent = threshold;\n    }\n\n    /// @dev gets called by router to affirm a deposit to an account\n    function registerDeposit(\n        address trader,\n        address token,\n        uint256 depositAmount\n    ) external override returns (uint256 extinguishableDebt) {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract not authorized to deposit\"\n        );\n\n        CrossMarginAccount storage account = marginAccounts[trader];\n        if (account.borrowed[token] > 0) {\n            extinguishableDebt = min(depositAmount, account.borrowed[token]);\n            extinguishDebt(account, token, extinguishableDebt);\n            totalShort[token] -= extinguishableDebt;\n        }\n        // no overflow because depositAmount >= extinguishableDebt\n        uint256 addedHolding = depositAmount - extinguishableDebt;\n        addHolding(account, token, addedHolding);\n\n        totalLong[token] += addedHolding;\n        require(\n            tokenCaps[token] >= totalLong[token],\n            \"Exceeding global exposure cap to token -- try again later\"\n        );\n\n        account.lastDepositBlock = block.number;\n    }\n\n    /// @dev gets called by router to affirm isolated borrowing event\n    function registerBorrow(\n        address trader,\n        address borrowToken,\n        uint256 borrowAmount\n    ) external override {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract not authorized to deposit\"\n        );\n        totalShort[borrowToken] += borrowAmount;\n        totalLong[borrowToken] += borrowAmount;\n        require(\n            tokenCaps[borrowToken] >= totalShort[borrowToken] &&\n                tokenCaps[borrowToken] >= totalLong[borrowToken],\n            \"Exceeding global exposure cap to token -- try again later\"\n        );\n\n        CrossMarginAccount storage account = marginAccounts[trader];\n        borrow(account, borrowToken, borrowAmount);\n    }\n\n    /// @dev gets called by router to affirm withdrawal of tokens from account\n    function registerWithdrawal(\n        address trader,\n        address withdrawToken,\n        uint256 withdrawAmount\n    ) external override {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract not authorized to deposit\"\n        );\n        CrossMarginAccount storage account = marginAccounts[trader];\n        require(\n            block.number > account.lastDepositBlock + coolingOffPeriod,\n            \"To prevent attacks you must wait until your cooling off period is over to withdraw\"\n        );\n\n        totalLong[withdrawToken] -= withdrawAmount;\n        // throws on underflow\n        account.holdings[withdrawToken] =\n            account.holdings[withdrawToken] -\n            withdrawAmount;\n        require(\n            positiveBalance(account),\n            \"Account balance is too low to withdraw\"\n        );\n    }\n\n    /// @dev gets callled by router to register a trade and borrow and extinguis as necessary\n    function registerTradeAndBorrow(\n        address trader,\n        address tokenFrom,\n        address tokenTo,\n        uint256 inAmount,\n        uint256 outAmount\n    )\n        external\n        override\n        returns (uint256 extinguishableDebt, uint256 borrowAmount)\n    {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract is not an authorized margin trader agent\"\n        );\n\n        CrossMarginAccount storage account = marginAccounts[trader];\n\n        if (account.borrowed[tokenTo] > 0) {\n            extinguishableDebt = min(outAmount, account.borrowed[tokenTo]);\n            extinguishDebt(account, tokenTo, extinguishableDebt);\n            totalShort[tokenTo] -= extinguishableDebt;\n        }\n        totalLong[tokenFrom] -= inAmount;\n        totalLong[tokenTo] += outAmount - extinguishableDebt;\n        require(\n            tokenCaps[tokenTo] >= totalLong[tokenTo],\n            \"Exceeding global exposure cap to token -- try again later\"\n        );\n\n        uint256 sellAmount = inAmount;\n        if (inAmount > account.holdings[tokenFrom]) {\n            sellAmount = account.holdings[tokenFrom];\n            /// won't overflow\n            borrowAmount = inAmount - sellAmount;\n\n            totalShort[tokenFrom] += borrowAmount;\n            require(\n                tokenCaps[tokenFrom] >= totalShort[tokenFrom],\n                \"Exceeding global exposure cap to token -- try again later\"\n            );\n\n            borrow(account, tokenFrom, borrowAmount);\n        }\n        adjustAmounts(account, tokenFrom, tokenTo, sellAmount, outAmount);\n    }\n}\n"
    },
    "contracts/Roles.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Roles is Ownable {\n    mapping(address => mapping(uint16 => bool)) public roles;\n    mapping(uint16 => address) public mainCharacters;\n\n    constructor() Ownable() {\n        // token activation from the get-go\n        roles[msg.sender][9] = true;\n    }\n\n    function giveRole(uint16 role, address actor) external onlyOwner {\n        roles[actor][role] = true;\n    }\n\n    function removeRole(uint16 role, address actor) external onlyOwner {\n        roles[actor][role] = false;\n    }\n\n    function setMainCharacter(uint16 role, address actor) external onlyOwner {\n        mainCharacters[role] = actor;\n    }\n\n    function getRole(uint16 role, address contr) external view returns (bool) {\n        return roles[contr][role];\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "interfaces/IWETH.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/Lending.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"./Fund.sol\";\nimport \"./HourlyBondSubscriptionLending.sol\";\nimport \"./BondLending.sol\";\nimport \"./IncentivizedHolder.sol\";\n\ncontract Lending is\n    BaseLending,\n    HourlyBondSubscriptionLending,\n    BondLending,\n    IncentivizedHolder\n{\n    /// @dev IDs for all bonds held by an address\n    mapping(address => uint256[]) public bondIds;\n\n    constructor(address _roles) RoleAware(_roles) Ownable() {\n        uint256 APR = 899;\n        maxHourlyYieldFP = (FP32 * APR) / 100 / (24 * 365);\n\n        uint256 aprChangePerMil = 3;\n        yieldChangePerSecondFP = (FP32 * aprChangePerMil) / 1000;\n    }\n\n    /// @dev how much interest has accrued to a borrowed balance over time\n    function applyBorrowInterest(\n        uint256 balance,\n        address token,\n        uint256 yieldQuotientFP\n    ) external returns (uint256 balanceWithInterest) {\n        YieldAccumulator storage yA = borrowYieldAccumulators[token];\n        balanceWithInterest = applyInterest(\n            balance,\n            yA.accumulatorFP,\n            yieldQuotientFP\n        );\n\n        uint256 deltaAmount = balanceWithInterest - balance;\n        totalBorrowed[token] += deltaAmount;\n    }\n\n    /// @dev view function to get current borrowing interest\n    function viewBorrowInterest(\n        uint256 balance,\n        address token,\n        uint256 yieldQuotientFP\n    ) external view returns (uint256) {\n        uint256 accumulatorFP =\n            viewCumulativeYieldFP(\n                token,\n                borrowYieldAccumulators,\n                block.timestamp\n            );\n        return applyInterest(balance, accumulatorFP, yieldQuotientFP);\n    }\n\n    /// @dev gets called by router to register if a trader borrows tokens\n    function registerBorrow(address token, uint256 amount) external {\n        require(isBorrower(msg.sender), \"Not an approved borrower\");\n        require(Fund(fund()).activeTokens(token), \"Not an approved token\");\n        totalBorrowed[token] += amount;\n        require(\n            totalLending[token] >= totalBorrowed[token],\n            \"Insufficient capital to lend, try again later!\"\n        );\n    }\n\n    /// @dev gets called by router if loan is extinguished\n    function payOff(address token, uint256 amount) external {\n        require(isBorrower(msg.sender), \"Not an approved borrower\");\n        totalBorrowed[token] -= amount;\n    }\n\n    /// @dev get the borrow yield\n    function viewBorrowingYieldFP(address token)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            viewCumulativeYieldFP(\n                token,\n                borrowYieldAccumulators,\n                block.timestamp\n            );\n    }\n\n    /// @dev In a liquidity crunch make a fallback bond until liquidity is good again\n    function _makeFallbackBond(\n        address token,\n        address holder,\n        uint256 amount\n    ) internal override {\n        _makeHourlyBond(token, holder, amount);\n    }\n\n    /// @dev withdraw an hour bond\n    function withdrawHourlyBond(address token, uint256 amount) external {\n        HourlyBond storage bond = hourlyBondAccounts[token][msg.sender];\n        // apply all interest\n        updateHourlyBondAmount(token, bond);\n        super._withdrawHourlyBond(token, bond, msg.sender, amount);\n\n        withdrawClaim(msg.sender, token, amount);\n    }\n\n    /// @dev buy hourly bond subscription\n    function buyHourlyBondSubscription(address token, uint256 amount) external {\n        if (lendingTarget(token) >= totalLending[token] + amount) {\n            require(\n                Fund(fund()).depositFor(msg.sender, token, amount),\n                \"Could not transfer bond deposit token to fund\"\n            );\n            super._makeHourlyBond(token, msg.sender, amount);\n\n            stakeClaim(msg.sender, token, amount);\n        }\n    }\n\n    /// @dev buy fixed term bond that does not renew\n    function buyBond(\n        address token,\n        uint256 runtime,\n        uint256 amount,\n        uint256 minReturn\n    ) external returns (uint256 bondIndex) {\n        if (\n            lendingTarget(token) >= totalLending[token] + amount &&\n            maxRuntime >= runtime &&\n            runtime >= minRuntime\n        ) {\n            bondIndex = super._makeBond(\n                msg.sender,\n                token,\n                runtime,\n                amount,\n                minReturn\n            );\n            bondIds[msg.sender].push(bondIndex);\n\n            stakeClaim(msg.sender, token, amount);\n        }\n    }\n\n    /// @dev send back funds of bond after maturity\n    function withdrawBond(uint256 bondId) external {\n        Bond storage bond = bonds[bondId];\n        require(msg.sender == bond.holder, \"Not holder of bond\");\n        require(\n            block.timestamp > bond.maturityTimestamp,\n            \"bond is still immature\"\n        );\n\n        super._withdrawBond(bond);\n        delete bonds[bondId];\n        // in case of a shortfall, governance can step in to provide\n        // additonal compensation beyond the usual incentive which\n        // gets withdrawn here\n        withdrawClaim(msg.sender, bond.token, bond.originalPrice);\n    }\n\n    function initBorrowYieldAccumulator(address token) external {\n        require(\n            isTokenActivator(msg.sender),\n            \"not autorized to init yield accumulator\"\n        );\n        borrowYieldAccumulators[token].accumulatorFP = FP32;\n    }\n\n    function setBorrowingFactorPercent(uint256 borrowingFactor)\n        external\n        onlyOwner\n    {\n        borrowingFactorPercent = borrowingFactor;\n    }\n}\n"
    },
    "contracts/MarginRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"../libraries/UniswapV2Library.sol\";\n\nimport \"./RoleAware.sol\";\nimport \"./Fund.sol\";\nimport \"../interfaces/IMarginTrading.sol\";\nimport \"./Lending.sol\";\nimport \"./Admin.sol\";\nimport \"./IncentivizedHolder.sol\";\n\ncontract MarginRouter is RoleAware, IncentivizedHolder, Ownable {\n    /// different uniswap compatible factories to talk to\n    mapping(address => bool) public factories;\n    /// wrapped ETH ERC20 contract\n    address public WETH;\n    address public constant UNI = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address public constant SUSHI = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;\n    /// emitted when a trader depoits on cross margin\n    event CrossDeposit(\n        address trader,\n        address depositToken,\n        uint256 depositAmount\n    );\n    /// emitted whenever a trade happens\n    event CrossTrade(\n        address trader,\n        address inToken,\n        uint256 inTokenAmount,\n        uint256 inTokenBorrow,\n        address outToken,\n        uint256 outTokenAmount,\n        uint256 outTokenExtinguish\n    );\n    /// emitted when a trader withdraws funds\n    event CrossWithdraw(\n        address trader,\n        address withdrawToken,\n        uint256 withdrawAmount\n    );\n    /// emitted upon sucessfully borrowing\n    event CrossBorrow(\n        address trader,\n        address borrowToken,\n        uint256 borrowAmount\n    );\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"Trade has expired\");\n        _;\n    }\n\n    constructor(address _WETH, address _roles) RoleAware(_roles) {\n        factories[UNI] = true;\n        factories[SUSHI] = true;\n\n        WETH = _WETH;\n    }\n\n    function authorizeAMM(address ammFactory) external onlyOwner {\n        factories[ammFactory] = true;\n    }\n\n    /// @dev traders call this to deposit funds on cross margin\n    function crossDeposit(address depositToken, uint256 depositAmount)\n        external\n    {\n        require(\n            Fund(fund()).depositFor(msg.sender, depositToken, depositAmount),\n            \"Cannot transfer deposit to margin account\"\n        );\n        uint256 extinguishAmount =\n            IMarginTrading(marginTrading()).registerDeposit(\n                msg.sender,\n                depositToken,\n                depositAmount\n            );\n        if (extinguishAmount > 0) {\n            Lending(lending()).payOff(depositToken, extinguishAmount);\n            withdrawClaim(msg.sender, depositToken, extinguishAmount);\n        }\n        emit CrossDeposit(msg.sender, depositToken, depositAmount);\n    }\n\n    /// @dev deposit wrapped ehtereum into cross margin account\n    function crossDepositETH() external payable {\n        Fund(fund()).depositToWETH{value: msg.value}();\n        uint256 extinguishAmount =\n            IMarginTrading(marginTrading()).registerDeposit(\n                msg.sender,\n                WETH,\n                msg.value\n            );\n        if (extinguishAmount > 0) {\n            Lending(lending()).payOff(WETH, extinguishAmount);\n            withdrawClaim(msg.sender, WETH, extinguishAmount);\n        }\n        emit CrossDeposit(msg.sender, WETH, msg.value);\n    }\n\n    /// @dev withdraw deposits/earnings from cross margin account\n    function crossWithdraw(address withdrawToken, uint256 withdrawAmount)\n        external\n    {\n        IMarginTrading(marginTrading()).registerWithdrawal(\n            msg.sender,\n            withdrawToken,\n            withdrawAmount\n        );\n        require(\n            Fund(fund()).withdraw(withdrawToken, msg.sender, withdrawAmount),\n            \"Could not withdraw from fund\"\n        );\n        emit CrossWithdraw(msg.sender, withdrawToken, withdrawAmount);\n    }\n\n    /// @dev withdraw ethereum from cross margin account\n    function crossWithdrawETH(uint256 withdrawAmount) external {\n        IMarginTrading(marginTrading()).registerWithdrawal(\n            msg.sender,\n            WETH,\n            withdrawAmount\n        );\n        Fund(fund()).withdrawETH(msg.sender, withdrawAmount);\n    }\n\n    /// @dev borrow into cross margin trading account\n    function crossBorrow(address borrowToken, uint256 borrowAmount) external {\n        Lending(lending()).registerBorrow(borrowToken, borrowAmount);\n        IMarginTrading(marginTrading()).registerBorrow(\n            msg.sender,\n            borrowToken,\n            borrowAmount\n        );\n\n        stakeClaim(msg.sender, borrowToken, borrowAmount);\n        emit CrossBorrow(msg.sender, borrowToken, borrowAmount);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        address factory,\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        for (uint256 i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) =\n                input == token0\n                    ? (uint256(0), amountOut)\n                    : (amountOut, uint256(0));\n            address to =\n                i < path.length - 2\n                    ? UniswapV2Library.pairFor(factory, output, path[i + 2])\n                    : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output))\n                .swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    /// @dev internal helper swapping exact token for token on AMM\n    function _swapExactT4T(\n        address factory,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) internal returns (uint256[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"MarginRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        require(\n            Fund(fund()).withdraw(\n                path[0],\n                UniswapV2Library.pairFor(factory, path[0], path[1]),\n                amounts[0]\n            ),\n            \"MarginRouter: Insufficient lending funds\"\n        );\n        _swap(factory, amounts, path, fund());\n    }\n\n    /// @dev external function to make swaps on AMM using protocol funds, only for authorized contracts\n    function authorizedSwapExactT4T(\n        address factory,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) external returns (uint256[] memory) {\n        require(\n            isAuthorizedFundTrader(msg.sender),\n            \"Calling contract is not authorized to trade with protocl funds\"\n        );\n        return _swapExactT4T(factory, amountIn, amountOutMin, path);\n    }\n\n    // @dev internal helper swapping exact token for token on on AMM\n    function _swapT4ExactT(\n        address factory,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path\n    ) internal returns (uint256[] memory amounts) {\n        // TODO minimum trade?\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(\n            amounts[0] <= amountInMax,\n            \"MarginRouter: EXCESSIVE_INPUT_AMOUNT\"\n        );\n        require(\n            Fund(fund()).withdraw(\n                path[0],\n                UniswapV2Library.pairFor(factory, path[0], path[1]),\n                amounts[0]\n            ),\n            \"MarginRouter: Insufficient lending funds\"\n        );\n        _swap(factory, amounts, path, fund());\n    }\n\n    //// @dev external function for swapping protocol funds on AMM, only for authorized\n    function authorizedSwapT4ExactT(\n        address factory,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path\n    ) external returns (uint256[] memory) {\n        require(\n            isAuthorizedFundTrader(msg.sender),\n            \"Calling contract is not authorized to trade with protocl funds\"\n        );\n        return _swapT4ExactT(factory, amountOut, amountInMax, path);\n    }\n\n    /// @dev entry point for swapping tokens held in cross margin account\n    function crossSwapExactTokensForTokens(\n        address ammFactory,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        // calc fees\n        uint256 fees =\n            Admin(feeController()).subtractTradingFees(path[0], amountIn);\n\n        requireAuthorizedAMM(ammFactory);\n        // swap\n        amounts = _swapExactT4T(\n            ammFactory,\n            amountIn - fees,\n            amountOutMin,\n            path\n        );\n\n        registerTrade(\n            msg.sender,\n            path[0],\n            path[path.length - 1],\n            amountIn,\n            amounts[amounts.length - 1]\n        );\n    }\n\n    /// @dev entry point for swapping tokens held in cross margin account\n    function crossSwapTokensForExactTokens(\n        address ammFactory,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        // calc fees\n        uint256 fees =\n            Admin(feeController()).addTradingFees(\n                path[path.length - 1],\n                amountOut\n            );\n\n        requireAuthorizedAMM(ammFactory);\n        // swap\n        amounts = _swapT4ExactT(\n            ammFactory,\n            amountOut + fees,\n            amountInMax,\n            path\n        );\n\n        registerTrade(\n            msg.sender,\n            path[0],\n            path[path.length - 1],\n            amounts[0],\n            amountOut\n        );\n    }\n\n    /// @dev helper function does all the work of telling other contracts\n    /// about a trade\n    function registerTrade(\n        address trader,\n        address inToken,\n        address outToken,\n        uint256 inAmount,\n        uint256 outAmount\n    ) internal {\n        (uint256 extinguishAmount, uint256 borrowAmount) =\n            IMarginTrading(marginTrading()).registerTradeAndBorrow(\n                trader,\n                inToken,\n                outToken,\n                inAmount,\n                outAmount\n            );\n        if (extinguishAmount > 0) {\n            Lending(lending()).payOff(outToken, extinguishAmount);\n            withdrawClaim(trader, outToken, extinguishAmount);\n        }\n        if (borrowAmount > 0) {\n            Lending(lending()).registerBorrow(inToken, borrowAmount);\n            stakeClaim(trader, inToken, borrowAmount);\n        }\n\n        emit CrossTrade(\n            trader,\n            inToken,\n            inAmount,\n            borrowAmount,\n            outToken,\n            outAmount,\n            extinguishAmount\n        );\n    }\n\n    function getAmountsOut(\n        address factory,\n        uint256 inAmount,\n        address[] calldata path\n    ) external view returns (uint256[] memory) {\n        return UniswapV2Library.getAmountsOut(factory, inAmount, path);\n    }\n\n    function getAmountsIn(\n        address factory,\n        uint256 outAmount,\n        address[] calldata path\n    ) external view returns (uint256[] memory) {\n        return UniswapV2Library.getAmountsIn(factory, outAmount, path);\n    }\n\n    function requireAuthorizedAMM(address ammFactory) internal view {\n        require(\n            ammFactory == UNI || ammFactory == SUSHI || factories[ammFactory],\n            \"Not using an authorized AMM\"\n        );\n    }\n}\n"
    },
    "contracts/CrossMarginLiquidation.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"./CrossMarginAccounts.sol\";\n\nabstract contract CrossMarginLiquidation is CrossMarginAccounts {\n    event LiquidationShortfall(uint256 amount);\n    event AccountLiquidated(address account);\n\n    struct Liquidation {\n        uint256 buy;\n        uint256 sell;\n        uint256 blockNum;\n    }\n\n    struct AccountLiqRecord {\n        uint256 blockNum;\n        address loser;\n        uint256 amount;\n        address stakeAttacker;\n    }\n\n    mapping(address => Liquidation) liquidationAmounts;\n    address[] sellTokens;\n    address[] buyTokens;\n    address[] tradersToLiquidate;\n\n    mapping(address => uint256) public maintenanceFailures;\n    mapping(address => AccountLiqRecord) public stakeAttackRecords;\n    uint256 public avgLiquidationPerBlock = 10;\n\n    uint256 public liqStakeAttackWindow = 5;\n    uint256 public MAINTAINER_CUT_PERCENT = 5;\n\n    uint256 public failureThreshold = 10;\n\n    function setFailureThreshold(uint256 threshFactor) external onlyOwner {\n        failureThreshold = threshFactor;\n    }\n\n    function setLiqStakeAttackWindow(uint256 window) external onlyOwner {\n        liqStakeAttackWindow = window;\n    }\n\n    function setMaintainerCutPercent(uint256 cut) external onlyOwner {\n        MAINTAINER_CUT_PERCENT = cut;\n    }\n\n    function calcLiquidationAmounts(\n        address[] memory liquidationCandidates,\n        bool isAuthorized\n    ) internal returns (uint256 attackReturns) {\n        sellTokens = new address[](0);\n        buyTokens = new address[](0);\n        tradersToLiquidate = new address[](0);\n\n        for (\n            uint256 traderIndex = 0;\n            liquidationCandidates.length > traderIndex;\n            traderIndex++\n        ) {\n            address traderAddress = liquidationCandidates[traderIndex];\n            CrossMarginAccount storage account = marginAccounts[traderAddress];\n            if (belowMaintenanceThreshold(account)) {\n                tradersToLiquidate.push(traderAddress);\n                for (\n                    uint256 sellIdx = 0;\n                    account.holdingTokens.length > sellIdx;\n                    sellIdx++\n                ) {\n                    address token = account.holdingTokens[sellIdx];\n                    Liquidation storage liquidation = liquidationAmounts[token];\n\n                    if (liquidation.blockNum != block.number) {\n                        liquidation.sell = account.holdings[token];\n                        liquidation.buy = 0;\n                        liquidation.blockNum = block.number;\n                        sellTokens.push(token);\n                    } else {\n                        liquidation.sell += account.holdings[token];\n                    }\n                }\n                for (\n                    uint256 buyIdx = 0;\n                    account.borrowTokens.length > buyIdx;\n                    buyIdx++\n                ) {\n                    address token = account.borrowTokens[buyIdx];\n                    Liquidation storage liquidation = liquidationAmounts[token];\n\n                    uint256 yield =\n                        Lending(lending()).viewBorrowingYieldFP(token);\n                    uint256 loanAmount =\n                        (account.borrowed[token] * yield) /\n                            account.borrowedYieldQuotientsFP[token];\n\n                    if (liquidation.blockNum != block.number) {\n                        liquidation.sell = 0;\n                        liquidation.buy = loanAmount;\n                        liquidation.blockNum = block.number;\n                        buyTokens.push(token);\n                    } else {\n                        liquidation.buy += loanAmount;\n                    }\n                }\n            }\n\n            AccountLiqRecord storage liqAttackRecord =\n                stakeAttackRecords[traderAddress];\n            if (isAuthorized) {\n                attackReturns += _disburseLiqAttack(liqAttackRecord);\n            }\n        }\n    }\n\n    function _disburseLiqAttack(AccountLiqRecord storage liqAttackRecord)\n        internal\n        returns (uint256 returnAmount)\n    {\n        if (liqAttackRecord.amount > 0) {\n            // validate attack records, if any\n            uint256 blockDiff =\n                min(\n                    block.number - liqAttackRecord.blockNum,\n                    liqStakeAttackWindow\n                );\n\n            uint256 attackerCut =\n                (liqAttackRecord.amount * blockDiff) / liqStakeAttackWindow;\n\n            Fund(fund()).withdraw(\n                PriceAware.peg,\n                liqAttackRecord.stakeAttacker,\n                attackerCut\n            );\n\n            Admin a = Admin(admin());\n            uint256 penalty =\n                (a.maintenanceStakePerBlock() * attackerCut) /\n                    avgLiquidationPerBlock;\n            a.penalizeMaintenanceStake(\n                liqAttackRecord.loser,\n                penalty,\n                liqAttackRecord.stakeAttacker\n            );\n\n            liqAttackRecord.amount = 0;\n            liqAttackRecord.stakeAttacker = address(0);\n            liqAttackRecord.blockNum = 0;\n            liqAttackRecord.loser = address(0);\n\n            returnAmount -= attackerCut;\n        }\n    }\n\n    function disburseLiqStakeAttacks(address[] memory liquidatedAccounts)\n        external\n    {\n        for (uint256 i = 0; liquidatedAccounts.length > i; i++) {\n            AccountLiqRecord storage liqAttackRecord =\n                stakeAttackRecords[liquidatedAccounts[i]];\n            if (\n                block.number > liqAttackRecord.blockNum + liqStakeAttackWindow\n            ) {\n                _disburseLiqAttack(liqAttackRecord);\n            }\n        }\n    }\n\n    function liquidateFromPeg() internal returns (uint256 pegAmount) {\n        for (uint256 tokenIdx = 0; buyTokens.length > tokenIdx; tokenIdx++) {\n            address buyToken = buyTokens[tokenIdx];\n            Liquidation storage liq = liquidationAmounts[buyToken];\n            if (liq.buy > liq.sell) {\n                pegAmount += PriceAware.liquidateToPeg(\n                    buyToken,\n                    liq.buy - liq.sell\n                );\n            }\n        }\n    }\n\n    function liquidateToPeg() internal returns (uint256 pegAmount) {\n        for (\n            uint256 tokenIndex = 0;\n            sellTokens.length > tokenIndex;\n            tokenIndex++\n        ) {\n            address token = sellTokens[tokenIndex];\n            Liquidation storage liq = liquidationAmounts[token];\n            if (liq.sell > liq.buy) {\n                uint256 sellAmount = liq.sell - liq.buy;\n                pegAmount += PriceAware.liquidateToPeg(token, sellAmount);\n            }\n        }\n    }\n\n    function maintainerIsFailing() internal view returns (bool) {\n        (address currentMaintainer, ) =\n            Admin(admin()).viewCurrentMaintenanceStaker();\n        return\n            maintenanceFailures[currentMaintainer] >\n            failureThreshold * avgLiquidationPerBlock;\n    }\n\n    /// called by maintenance stakers to liquidate accounts below liquidation threshold\n    function liquidate(address[] memory liquidationCandidates)\n        external\n        returns (uint256 maintainerCut)\n    {\n        bool isAuthorized = Admin(admin()).isAuthorizedStaker(msg.sender);\n        bool canTakeNow = isAuthorized || maintainerIsFailing();\n\n        // calcLiquidationAmounts does a lot of the work her\n        // * aggregates both sell and buy side targets to be liquidated\n        // * returns attacker cuts to them\n        // * aggregates any returned fees from unauthorized (attacking) attempts\n        uint256 attackReturns2Authorized =\n            calcLiquidationAmounts(liquidationCandidates, isAuthorized);\n        maintainerCut = attackReturns2Authorized;\n\n        uint256 sale2pegAmount = liquidateToPeg();\n        uint256 peg2targetCost = liquidateFromPeg();\n\n        // this may be a bit imprecise, since individual shortfalls may be obscured\n        // by overall returns and the maintainer cut is taken out of the net total,\n        // but it gives us the general picture\n        if (\n            (peg2targetCost * (100 + MAINTAINER_CUT_PERCENT)) / 100 >\n            sale2pegAmount\n        ) {\n            emit LiquidationShortfall(peg2targetCost - sale2pegAmount);\n        }\n\n        address loser = address(0);\n        if (!canTakeNow) {\n            // whoever is the current responsible maintenance staker\n            // and liable to lose their stake\n            loser = Admin(admin()).getUpdatedCurrentStaker();\n        }\n\n        // iterate over traders and send back their money\n        // as well as giving attackers their due, in case caller isn't authorized\n        for (\n            uint256 traderIdx = 0;\n            tradersToLiquidate.length > traderIdx;\n            traderIdx++\n        ) {\n            address traderAddress = tradersToLiquidate[traderIdx];\n            CrossMarginAccount storage account = marginAccounts[traderAddress];\n\n            uint256 holdingsValue = holdingsInPeg(account, true);\n            uint256 borrowValue = loanInPeg(account, true);\n            // 5% of value borrowed\n            uint256 maintainerCut4Account =\n                (borrowValue * MAINTAINER_CUT_PERCENT) / 100;\n            maintainerCut += maintainerCut4Account;\n\n            if (!canTakeNow) {\n                // This could theoretically lead to a previous attackers\n                // record being overwritten, but only if the trader restarts\n                // their account and goes back into the red within the short time window\n                // which would be a costly attack requiring collusion without upside\n                AccountLiqRecord storage liqAttackRecord =\n                    stakeAttackRecords[traderAddress];\n                liqAttackRecord.amount = maintainerCut4Account;\n                liqAttackRecord.stakeAttacker = msg.sender;\n                liqAttackRecord.blockNum = block.number;\n                liqAttackRecord.loser = loser;\n            }\n\n            // send back trader money\n            if (holdingsValue >= maintainerCut4Account + borrowValue) {\n                // send remaining funds back to trader\n                Fund(fund()).withdraw(\n                    PriceAware.peg,\n                    traderAddress,\n                    holdingsValue - borrowValue - maintainerCut4Account\n                );\n            }\n\n            emit AccountLiquidated(traderAddress);\n            deleteAccount(account);\n        }\n\n        avgLiquidationPerBlock =\n            (avgLiquidationPerBlock * 99 + maintainerCut) /\n            100;\n\n        address currentMaintainer = Admin(admin()).getUpdatedCurrentStaker();\n        if (isAuthorized) {\n            if (maintenanceFailures[currentMaintainer] > maintainerCut) {\n                maintenanceFailures[currentMaintainer] -= maintainerCut;\n            } else {\n                maintenanceFailures[currentMaintainer] = 0;\n            }\n        } else {\n            maintenanceFailures[currentMaintainer] += maintainerCut;\n        }\n    }\n}\n"
    },
    "contracts/HourlyBondSubscriptionLending.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"./BaseLending.sol\";\nimport \"./Fund.sol\";\n\nstruct YieldAccumulator {\n    uint256 accumulatorFP;\n    uint256 lastUpdated;\n    uint256 hourlyYieldFP;\n}\n\nstruct HourlyBond {\n    uint256 amount;\n    uint256 yieldQuotientFP;\n    uint256 moduloHour;\n}\n\nabstract contract HourlyBondSubscriptionLending is BaseLending {\n    uint256 withdrawalWindow = 10 minutes;\n    // token => holder => bond record\n    mapping(address => mapping(address => HourlyBond))\n        public hourlyBondAccounts;\n\n    mapping(address => YieldAccumulator) public hourlyBondYieldAccumulators;\n    /// @dev accumulate interest per token (like compound indices)\n    mapping(address => YieldAccumulator) public borrowYieldAccumulators;\n\n    uint256 public borrowingFactorPercent = 200;\n\n    mapping(address => uint256) public hourlyBondBuyingSpeed;\n    mapping(address => uint256) public hourlyBondWithdrawingSpeed;\n\n    function setHourlyYieldAPR(address token, uint256 aprPercent) external {\n        require(\n            isTokenActivator(msg.sender),\n            \"not autorized to set hourly yield\"\n        );\n        if (hourlyBondYieldAccumulators[token].accumulatorFP == 0) {\n            hourlyBondYieldAccumulators[token] = YieldAccumulator({\n                accumulatorFP: FP32,\n                lastUpdated: block.timestamp,\n                hourlyYieldFP: (FP32 * (100 + aprPercent)) / 100 / (24 * 365)\n            });\n        } else {\n            hourlyBondYieldAccumulators[token].hourlyYieldFP =\n                (FP32 * (100 + aprPercent)) /\n                100 /\n                (24 * 365);\n        }\n    }\n\n    function setWithdrawalWindow(uint256 window) external onlyOwner {\n        withdrawalWindow = window;\n    }\n\n    function _makeHourlyBond(\n        address token,\n        address holder,\n        uint256 amount\n    ) internal {\n        HourlyBond storage bond = hourlyBondAccounts[token][holder];\n        updateHourlyBondAmount(token, bond);\n        bond.yieldQuotientFP = hourlyBondYieldAccumulators[token].accumulatorFP;\n        bond.moduloHour = block.timestamp % (1 hours);\n        bond.amount += amount;\n        totalLending[token] += amount;\n    }\n\n    function updateHourlyBondAmount(address token, HourlyBond storage bond)\n        internal\n    {\n        uint256 yieldQuotientFP = bond.yieldQuotientFP;\n        if (yieldQuotientFP > 0) {\n            YieldAccumulator storage yA = getUpdatedHourlyYield(token);\n\n            uint256 oldAmount = bond.amount;\n            bond.amount = applyInterest(\n                bond.amount,\n                yA.accumulatorFP,\n                yieldQuotientFP\n            );\n\n            uint256 deltaAmount = bond.amount - oldAmount;\n            totalLending[token] += deltaAmount;\n        }\n    }\n\n    function _withdrawHourlyBond(\n        address token,\n        HourlyBond storage bond,\n        address recipient,\n        uint256 amount\n    ) internal {\n        // how far the current hour has advanced (relative to acccount hourly clock)\n        uint256 currentOffset = (block.timestamp - bond.moduloHour) % (1 hours);\n\n        require(\n            withdrawalWindow >= currentOffset,\n            \"Tried withdrawing outside subscription cancellation time window\"\n        );\n\n        require(\n            Fund(fund()).withdraw(token, recipient, amount),\n            \"Insufficient liquidity\"\n        );\n\n        bond.amount -= amount;\n        totalLending[token] -= amount;\n    }\n\n    function closeHourlyBondAccount(address token) external {\n        HourlyBond storage bond = hourlyBondAccounts[token][msg.sender];\n        // apply all interest\n        updateHourlyBondAmount(token, bond);\n        _withdrawHourlyBond(token, bond, msg.sender, bond.amount);\n        bond.amount = 0;\n        bond.yieldQuotientFP = 0;\n        bond.moduloHour = 0;\n    }\n\n    function calcCumulativeYieldFP(\n        YieldAccumulator storage yieldAccumulator,\n        uint256 timeDelta\n    ) internal view returns (uint256 accumulatorFP) {\n        uint256 secondsDelta = timeDelta % (1 hours);\n        // linearly interpolate interest for seconds\n        // accumulator * hourly_yield == seconds_per_hour * accumulator * hourly_yield / seconds_per_hour\n        // FP * FP * 1 / (FP * 1) = FP\n        accumulatorFP =\n            (yieldAccumulator.accumulatorFP *\n                yieldAccumulator.hourlyYieldFP *\n                secondsDelta) /\n            (FP32 * 1 hours);\n\n        uint256 hoursDelta = timeDelta / (1 hours);\n        if (hoursDelta > 0) {\n            // This loop should hardly ever 1 or more unless something bad happened\n            // In which case it costs gas but there isn't overflow\n            for (uint256 i = 0; hoursDelta > i; i++) {\n                // FP32 * FP32 / FP32 = FP32\n                accumulatorFP =\n                    (accumulatorFP * yieldAccumulator.hourlyYieldFP) /\n                    FP32;\n            }\n        }\n    }\n\n    /// @dev updates yield accumulators for both borrowing and lending\n    function getUpdatedHourlyYield(address token)\n        internal\n        returns (YieldAccumulator storage accumulator)\n    {\n        accumulator = hourlyBondYieldAccumulators[token];\n        uint256 timeDelta = (block.timestamp - accumulator.lastUpdated);\n\n        accumulator.accumulatorFP = calcCumulativeYieldFP(\n            accumulator,\n            timeDelta\n        );\n\n        accumulator.hourlyYieldFP = updatedYieldFP(\n            accumulator.hourlyYieldFP,\n            accumulator.lastUpdated,\n            totalLending[token],\n            lendingTarget(token),\n            hourlyBondBuyingSpeed[token],\n            hourlyBondWithdrawingSpeed[token],\n            maxHourlyYieldFP\n        );\n\n        YieldAccumulator storage borrowAccumulator =\n            borrowYieldAccumulators[token];\n        timeDelta = block.timestamp - borrowAccumulator.lastUpdated;\n        borrowAccumulator.accumulatorFP = calcCumulativeYieldFP(\n            borrowAccumulator,\n            timeDelta\n        );\n\n        borrowYieldAccumulators[token].hourlyYieldFP =\n            (borrowingFactorPercent * accumulator.hourlyYieldFP) /\n            100;\n\n        accumulator.lastUpdated = block.timestamp;\n        borrowAccumulator.lastUpdated = block.timestamp;\n    }\n\n    function viewCumulativeYieldFP(\n        address token,\n        mapping(address => YieldAccumulator) storage yieldAccumulators,\n        uint256 timestamp\n    ) internal view returns (uint256) {\n        uint256 timeDelta = (timestamp - yieldAccumulators[token].lastUpdated);\n        return calcCumulativeYieldFP(yieldAccumulators[token], timeDelta);\n    }\n}\n"
    },
    "contracts/BondLending.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\nimport \"./BaseLending.sol\";\nimport \"./Fund.sol\";\n\nstruct Bond {\n    address holder;\n    address token;\n    uint256 originalPrice;\n    uint256 returnAmount;\n    uint256 maturityTimestamp;\n    uint256 runtime;\n    uint256 yieldFP;\n}\n\nabstract contract BondLending is BaseLending {\n    uint256 public minRuntime = 30 days;\n    uint256 public maxRuntime = 365 days;\n    uint256 public diffMaxMinRuntime;\n    // this is the numerator under runtimeWeights.\n    // any excess left over is the weight of hourly bonds\n    uint256 public constant WEIGHT_TOTAL_10k = 10_000;\n    uint256 public borrowingMarkupFP;\n\n    mapping(address => uint256[]) public runtimeWeights;\n    mapping(address => uint256[]) public buyingSpeed;\n    mapping(address => uint256[]) public lastBought;\n    mapping(address => uint256[]) public withdrawingSpeed;\n    mapping(address => uint256[]) public lastWithdrawn;\n    mapping(address => uint256[]) public yieldLastUpdated;\n\n    mapping(uint256 => Bond) public bonds;\n\n    mapping(address => uint256[]) public totalLendingPerRuntime;\n    mapping(address => uint256[]) runtimeYieldsFP;\n    uint256 public nextBondIndex = 1;\n\n    event LiquidityWarning(\n        address indexed token,\n        address indexed holder,\n        uint256 value\n    );\n\n    function _makeBond(\n        address holder,\n        address token,\n        uint256 runtime,\n        uint256 amount,\n        uint256 minReturn\n    ) internal returns (uint256 bondIndex) {\n        uint256 bucketIndex = getBucketIndex(token, runtime);\n        uint256 yieldFP =\n            calcBondYieldFP(\n                token,\n                amount + totalLendingPerRuntime[token][bucketIndex],\n                bucketIndex\n            );\n        uint256 bondReturn = (yieldFP * amount) / FP32;\n        if (bondReturn >= minReturn) {\n            if (Fund(fund()).depositFor(holder, token, amount)) {\n                uint256 interpolatedAmount = (amount + bondReturn) / 2;\n                totalLending[token] += interpolatedAmount;\n\n                totalLendingPerRuntime[token][\n                    bucketIndex\n                ] += interpolatedAmount;\n\n                bondIndex = nextBondIndex;\n                nextBondIndex++;\n\n                bonds[bondIndex] = Bond({\n                    holder: holder,\n                    token: token,\n                    originalPrice: amount,\n                    returnAmount: bondReturn,\n                    maturityTimestamp: block.timestamp + runtime,\n                    runtime: runtime,\n                    yieldFP: yieldFP\n                });\n\n                updateSpeed(\n                    buyingSpeed[token],\n                    lastBought[token],\n                    bucketIndex,\n                    amount\n                );\n            }\n        }\n    }\n\n    function _withdrawBond(Bond storage bond) internal {\n        address token = bond.token;\n        uint256 bucketIndex = getBucketIndex(token, bond.runtime);\n        uint256 interpolatedAmount =\n            (bond.originalPrice + bond.returnAmount) / 2;\n        totalLending[token] -= interpolatedAmount;\n        totalLendingPerRuntime[token][bucketIndex] -= interpolatedAmount;\n\n        updateSpeed(\n            withdrawingSpeed[token],\n            lastWithdrawn[token],\n            bucketIndex,\n            bond.originalPrice\n        );\n\n        if (\n            totalBorrowed[token] > totalLending[token] ||\n            !Fund(fund()).withdraw(token, bond.holder, bond.returnAmount)\n        ) {\n            // apparently there is a liquidity issue\n            emit LiquidityWarning(token, bond.holder, bond.returnAmount);\n            _makeFallbackBond(token, bond.holder, bond.returnAmount);\n        }\n    }\n\n    function getUpdatedBondYieldFP(\n        address token,\n        uint256 runtime,\n        uint256 amount\n    ) internal returns (uint256 yieldFP, uint256 bucketIndex) {\n        bucketIndex = getBucketIndex(token, runtime);\n        yieldFP = calcBondYieldFP(\n            token,\n            amount + totalLendingPerRuntime[token][bucketIndex],\n            bucketIndex\n        );\n        runtimeYieldsFP[token][bucketIndex] = yieldFP;\n        yieldLastUpdated[token][bucketIndex] = block.timestamp;\n    }\n\n    function calcBondYieldFP(\n        address token,\n        uint256 totalLendingInBucket,\n        uint256 bucketIndex\n    ) internal view returns (uint256 yieldFP) {\n        yieldFP = runtimeYieldsFP[token][bucketIndex];\n        uint256 lastUpdated = yieldLastUpdated[token][bucketIndex];\n\n        uint256 bucketTarget =\n            (lendingTarget(token) * runtimeWeights[token][bucketIndex]) /\n                WEIGHT_TOTAL_10k;\n\n        uint256 buying = buyingSpeed[token][bucketIndex];\n        uint256 withdrawing = withdrawingSpeed[token][bucketIndex];\n\n        uint256 runtime = minRuntime + bucketIndex * diffMaxMinRuntime;\n        uint256 bucketMaxYield = maxHourlyYieldFP * (runtime / (1 hours));\n\n        yieldFP = updatedYieldFP(\n            yieldFP,\n            lastUpdated,\n            totalLendingInBucket,\n            bucketTarget,\n            buying,\n            withdrawing,\n            bucketMaxYield\n        );\n    }\n\n    function viewBondReturn(\n        address token,\n        uint256 runtime,\n        uint256 amount\n    ) external view returns (uint256) {\n        uint256 bucketIndex = getBucketIndex(token, runtime);\n        uint256 yieldFP =\n            calcBondYieldFP(\n                token,\n                amount + totalLendingPerRuntime[token][bucketIndex],\n                bucketIndex\n            );\n        return (yieldFP * amount) / FP32;\n    }\n\n    function getBucketIndex(address token, uint256 runtime)\n        internal\n        view\n        returns (uint256 bucketIndex)\n    {\n        uint256[] storage yieldsFP = runtimeYieldsFP[token];\n        uint256 bucketSize = diffMaxMinRuntime / yieldsFP.length;\n        bucketIndex = (runtime - minRuntime) / bucketSize;\n    }\n\n    function updateSpeed(\n        uint256[] storage speedRegister,\n        uint256[] storage lastAction,\n        uint256 bucketIndex,\n        uint256 amount\n    ) internal {\n        uint256 bucketSize = diffMaxMinRuntime / speedRegister.length;\n        uint256 runtime = minRuntime + bucketSize * bucketIndex;\n        uint256 timeDiff = block.timestamp - lastAction[bucketIndex];\n        uint256 currentSpeed = (amount * runtime) / (timeDiff + 1);\n\n        uint256 runtimeScale = runtime / (10 minutes);\n        // scale adjustment relative togit  runtime\n        speedRegister[bucketIndex] =\n            (speedRegister[bucketIndex] *\n                runtimeScale +\n                currentSpeed *\n                timeDiff) /\n            (runtimeScale + timeDiff);\n        lastAction[bucketIndex] = block.timestamp;\n    }\n\n    function setRuntimeYieldsFP(address token, uint256[] memory yieldsFP)\n        external\n        onlyOwner\n    {\n        runtimeYieldsFP[token] = yieldsFP;\n    }\n\n    function setRuntimeWeights(address token, uint256[] memory weights)\n        external\n    {\n        //require(\n        //    isTokenActivator(msg.sender),\n        //    \"not autorized to set runtime weights\"\n        //);\n        require(\n            runtimeWeights[token].length == 0 ||\n                runtimeWeights[token].length == weights.length,\n            \"Cannot change size of weight array\"\n        );\n        if (runtimeWeights[token].length == 0) {\n            // we are initializing\n\n            runtimeYieldsFP[token] = new uint256[](weights.length);\n            lastBought[token] = new uint256[](weights.length);\n            lastWithdrawn[token] = new uint256[](weights.length);\n            yieldLastUpdated[token] = new uint256[](weights.length);\n            buyingSpeed[token] = new uint256[](weights.length);\n            withdrawingSpeed[token] = new uint256[](weights.length);\n\n            uint256 hourlyYieldFP = (110 * FP32) / 100 / (24 * 365);\n            uint256 bucketSize = diffMaxMinRuntime / weights.length;\n\n            for (uint24 i = 0; weights.length > i; i++) {\n                uint256 runtime = minRuntime + bucketSize * i;\n                // Do a best guess of initializing\n                runtimeYieldsFP[token][i] =\n                    hourlyYieldFP *\n                    (runtime / (1 hours));\n\n                lastBought[token][i] = block.timestamp;\n                lastWithdrawn[token][i] = block.timestamp;\n                yieldLastUpdated[token][i] = block.timestamp;\n            }\n        }\n\n        runtimeWeights[token] = weights;\n    }\n\n    function setMinRuntime(uint256 runtime) external onlyOwner {\n        require(runtime > 1 hours, \"Min runtime needs to be at least 1 hour\");\n        minRuntime = runtime;\n    }\n\n    function setMaxRuntime(uint256 runtime) external onlyOwner {\n        require(\n            runtime > minRuntime,\n            \"Max runtime must be greater than min runtime\"\n        );\n        maxRuntime = runtime;\n    }\n}\n"
    },
    "contracts/IncentivizedHolder.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"./IncentiveDistribution.sol\";\nimport \"./RoleAware.sol\";\n\nabstract contract IncentivizedHolder is RoleAware {\n    // here we cache incentive tranches to save on a bit of gas\n    mapping(address => uint8) public incentiveTranches;\n    // claimant => token => claimId\n    mapping(address => mapping(address => uint256)) public claimIds;\n\n    function setIncentiveTranche(address token, uint8 tranche) external {\n        require(\n            isTokenActivator(msg.sender),\n            \"Caller not authorized to set incentive tranche\"\n        );\n        incentiveTranches[token] = tranche;\n    }\n\n    function stakeClaim(\n        address claimant,\n        address token,\n        uint256 amount\n    ) internal {\n        IncentiveDistribution iD =\n            IncentiveDistribution(incentiveDistributor());\n        uint256 claimId = claimIds[claimant][token];\n        uint8 tranche = incentiveTranches[token];\n        if (claimId > 0) {\n            iD.addToClaimAmount(tranche, claimId, amount);\n        } else {\n            claimId = iD.startClaim(tranche, claimant, amount);\n            claimIds[claimant][token] = claimId;\n        }\n    }\n\n    function withdrawClaim(\n        address claimant,\n        address token,\n        uint256 amount\n    ) internal {\n        uint256 claimId = claimIds[claimant][token];\n        uint8 tranche = incentiveTranches[token];\n        IncentiveDistribution(incentiveDistributor()).subtractFromClaimAmount(\n            tranche,\n            claimId,\n            amount\n        );\n    }\n}\n"
    },
    "contracts/BaseLending.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\nimport \"./RoleAware.sol\";\n\nabstract contract BaseLending is RoleAware, Ownable {\n    uint256 constant FP32 = 2**32;\n    uint256 constant ACCUMULATOR_INIT = 10**18;\n\n    mapping(address => uint256) public totalLending;\n    mapping(address => uint256) public totalBorrowed;\n    mapping(address => uint256) public lendingBuffer;\n    mapping(address => uint256) public lendingCap;\n\n    uint256 public maxHourlyYieldFP;\n    uint256 public yieldChangePerSecondFP;\n\n    /// @dev simple formula for calculating interest relative to accumulator\n    function applyInterest(\n        uint256 balance,\n        uint256 accumulatorFP,\n        uint256 yieldQuotientFP\n    ) internal pure returns (uint256) {\n        // 1 * FP / FP = 1\n        return (balance * accumulatorFP) / yieldQuotientFP;\n    }\n\n    /// update the yield for an asset based on recent supply and demand\n    function updatedYieldFP(\n        // previous yield\n        uint256 _yieldFP,\n        // timestamp\n        uint256 lastUpdated,\n        uint256 totalLendingInBucket,\n        uint256 bucketTarget,\n        uint256 buyingSpeed,\n        uint256 withdrawingSpeed,\n        uint256 bucketMaxYield\n    ) internal view returns (uint256 yieldFP) {\n        yieldFP = _yieldFP;\n        uint256 timeDiff = block.timestamp - lastUpdated;\n        uint256 yieldDiff = timeDiff * yieldChangePerSecondFP;\n\n        if (\n            totalLendingInBucket >= bucketTarget ||\n            buyingSpeed >= withdrawingSpeed\n        ) {\n            yieldFP -= min(yieldFP, yieldDiff);\n        } else if (\n            bucketTarget > totalLendingInBucket &&\n            withdrawingSpeed > buyingSpeed\n        ) {\n            yieldFP += yieldDiff;\n            if (yieldFP > bucketMaxYield) {\n                yieldFP = bucketMaxYield;\n            }\n        }\n    }\n\n    /// @dev minimum\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return b;\n        } else {\n            return a;\n        }\n    }\n\n    function _makeFallbackBond(\n        address token,\n        address holder,\n        uint256 amount\n    ) internal virtual;\n\n    function lendingTarget(address token) public view returns (uint256) {\n        return\n            min(lendingCap[token], totalBorrowed[token] + lendingBuffer[token]);\n    }\n\n    function setLendingCap(address token, uint256 cap) external {\n        require(\n            isTokenActivator(msg.sender),\n            \"not authorized to set lending cap\"\n        );\n        lendingCap[token] = cap;\n    }\n\n    function setLendingBuffer(address token, uint256 buffer) external {\n        require(\n            isTokenActivator(msg.sender),\n            \"not autorized to set lending buffer\"\n        );\n        lendingBuffer[token] = buffer;\n    }\n\n    function setMaxHourlyYieldFP(uint256 maxYieldFP) external onlyOwner {\n        maxHourlyYieldFP = maxYieldFP;\n    }\n\n    function setYieldChangePerSecondFP(uint256 changePerSecondFP)\n        external\n        onlyOwner\n    {\n        yieldChangePerSecondFP = changePerSecondFP;\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "libraries/UniswapV2Library.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\nlibrary UniswapV2Library {\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            bytes20(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        factory,\n                        keccak256(abi.encodePacked(token0, token1)),\n                        hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n                    )\n                )\n            )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) =\n            IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA > 0 && reserveB > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) - 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) =\n                getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) =\n                getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "interfaces/IMarginTrading.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\ninterface IMarginTrading {\n    function registerDeposit(\n        address trader,\n        address token,\n        uint256 amount\n    ) external returns (uint256 extinguishAmount);\n\n    function registerWithdrawal(\n        address trader,\n        address token,\n        uint256 amount\n    ) external;\n\n    function registerBorrow(\n        address trader,\n        address token,\n        uint256 amount\n    ) external;\n\n    function registerTradeAndBorrow(\n        address trader,\n        address inToken,\n        address outToken,\n        uint256 inAmount,\n        uint256 outAmount\n    ) external returns (uint256 extinguishAmount, uint256 borrowAmount);\n    // TODO\n    // in router have list of paths..?\n    // function registerLiquidation(address trader) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/CrossMarginAccounts.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Fund.sol\";\nimport \"./Lending.sol\";\nimport \"./RoleAware.sol\";\nimport \"./MarginRouter.sol\";\nimport \"./PriceAware.sol\";\n\n// Goal: all external functions only accessible to margintrader role\n// except for view functions of course\n\nstruct CrossMarginAccount {\n    uint256 lastDepositBlock;\n    address[] borrowTokens;\n    // borrowed token address => amount\n    mapping(address => uint256) borrowed;\n    // borrowed token => yield quotient\n    mapping(address => uint256) borrowedYieldQuotientsFP;\n    address[] holdingTokens;\n    // token held in portfolio => amount\n    mapping(address => uint256) holdings;\n    // boolean value of whether an account holds a token\n    mapping(address => bool) holdsToken;\n}\n\nabstract contract CrossMarginAccounts is RoleAware, PriceAware {\n    /// @dev gets used in calculating how much accounts can borrow\n    uint256 public leverage;\n\n    /// @dev percentage of assets held per assets borrowed at which to liquidate\n    uint256 public liquidationThresholdPercent;\n\n    /// @dev record of all cross margin accounts\n    mapping(address => CrossMarginAccount) marginAccounts;\n    /// @dev total token caps\n    mapping(address => uint256) public tokenCaps;\n    /// @dev tracks total of short positions per token\n    mapping(address => uint256) public totalShort;\n    /// @dev tracks total of long positions per token\n    mapping(address => uint256) public totalLong;\n    uint256 public coolingOffPeriod;\n\n    /// @dev view function to display account held assets state\n    function getHoldingAmounts(address trader)\n        external\n        view\n        returns (\n            address[] memory holdingTokens,\n            uint256[] memory holdingAmounts\n        )\n    {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        holdingTokens = account.holdingTokens;\n\n        holdingAmounts = new uint256[](account.holdingTokens.length);\n        for (uint256 idx = 0; holdingTokens.length > idx; idx++) {\n            address tokenAddress = holdingTokens[idx];\n            holdingAmounts[idx] = account.holdings[tokenAddress];\n        }\n\n        (holdingTokens, holdingAmounts);\n    }\n\n    /// @dev view function to display account borrowing state\n    function getBorrowAmounts(address trader)\n        external\n        view\n        returns (address[] memory borrowTokens, uint256[] memory borrowAmounts)\n    {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        borrowTokens = account.borrowTokens;\n\n        borrowAmounts = new uint256[](account.borrowTokens.length);\n        for (uint256 idx = 0; borrowTokens.length > idx; idx++) {\n            address tokenAddress = borrowTokens[idx];\n            borrowAmounts[idx] = Lending(lending()).viewBorrowInterest(\n                account.borrowed[tokenAddress],\n                tokenAddress,\n                account.borrowedYieldQuotientsFP[tokenAddress]\n            );\n        }\n\n        (borrowTokens, borrowAmounts);\n    }\n\n    /// @dev last time this account deposited\n    /// relevant for withdrawal window\n    function getLastDepositBlock(address trader)\n        external\n        view\n        returns (uint256)\n    {\n        return marginAccounts[trader].lastDepositBlock;\n    }\n\n    /// @dev add an asset to be held by account\n    function addHolding(\n        CrossMarginAccount storage account,\n        address token,\n        uint256 depositAmount\n    ) internal {\n        if (!hasHoldingToken(account, token)) {\n            account.holdingTokens.push(token);\n        }\n\n        account.holdings[token] += depositAmount;\n    }\n\n    /// @dev adjust account to reflect borrowing of token amount\n    function borrow(\n        CrossMarginAccount storage account,\n        address borrowToken,\n        uint256 borrowAmount\n    ) internal {\n        if (!hasBorrowedToken(account, borrowToken)) {\n            account.borrowTokens.push(borrowToken);\n        } else {\n            account.borrowed[borrowToken] = Lending(lending())\n                .applyBorrowInterest(\n                account.borrowed[borrowToken],\n                borrowToken,\n                account.borrowedYieldQuotientsFP[borrowToken]\n            );\n        }\n        account.borrowedYieldQuotientsFP[borrowToken] = Lending(lending())\n            .viewBorrowingYieldFP(borrowToken);\n\n        account.borrowed[borrowToken] += borrowAmount;\n        addHolding(account, borrowToken, borrowAmount);\n\n        require(positiveBalance(account), \"Can't borrow: insufficient balance\");\n    }\n\n    /// @dev checks whether account is in the black, deposit + earnings relative to borrowed\n    function positiveBalance(CrossMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account, false);\n        uint256 holdings = holdingsInPeg(account, false);\n        // The following condition should hold:\n        // holdings / loan >= leverage / (leverage - 1)\n        // =>\n        return holdings * (leverage - 1) >= loan * leverage;\n    }\n\n    /// @dev internal function adjusting holding and borrow balances when debt extinguished\n    function extinguishDebt(\n        CrossMarginAccount storage account,\n        address debtToken,\n        uint256 extinguishAmount\n    ) internal {\n        // will throw if insufficient funds\n        account.borrowed[debtToken] = Lending(lending()).applyBorrowInterest(\n            account.borrowed[debtToken],\n            debtToken,\n            account.borrowedYieldQuotientsFP[debtToken]\n        );\n\n        account.borrowed[debtToken] =\n            account.borrowed[debtToken] -\n            extinguishAmount;\n        account.holdings[debtToken] =\n            account.holdings[debtToken] -\n            extinguishAmount;\n\n        if (account.borrowed[debtToken] > 0) {\n            account.borrowedYieldQuotientsFP[debtToken] = Lending(lending())\n                .viewBorrowingYieldFP(debtToken);\n        }\n    }\n\n    /// @dev checks whether an account holds a token\n    function hasHoldingToken(CrossMarginAccount storage account, address token)\n        internal\n        view\n        returns (bool)\n    {\n        return account.holdsToken[token];\n    }\n\n    /// @dev checks whether an account has borrowed a token\n    function hasBorrowedToken(CrossMarginAccount storage account, address token)\n        internal\n        view\n        returns (bool)\n    {\n        return account.borrowedYieldQuotientsFP[token] > 0;\n    }\n\n    /// @dev calculate total loan in reference currency, including compound interest\n    function loanInPeg(CrossMarginAccount storage account, bool forceCurBlock)\n        internal\n        returns (uint256)\n    {\n        return\n            sumTokensInPegWithYield(\n                account.borrowTokens,\n                account.borrowed,\n                account.borrowedYieldQuotientsFP,\n                forceCurBlock\n            );\n    }\n\n    /// @dev total of assets of account, expressed in reference currency\n    function holdingsInPeg(\n        CrossMarginAccount storage account,\n        bool forceCurBlock\n    ) internal returns (uint256) {\n        return\n            sumTokensInPeg(\n                account.holdingTokens,\n                account.holdings,\n                forceCurBlock\n            );\n    }\n\n    /// @dev check whether an account can/should be liquidated\n    function belowMaintenanceThreshold(CrossMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account, true);\n        uint256 holdings = holdingsInPeg(account, true);\n        // The following should hold:\n        // holdings / loan >= 1.1\n        // => holdings >= loan * 1.1\n        return 100 * holdings >= liquidationThresholdPercent * loan;\n    }\n\n    /// @dev go through list of tokens and their amounts, summing up\n    function sumTokensInPeg(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts,\n        bool forceCurBlock\n    ) internal returns (uint256 totalPeg) {\n        for (uint256 tokenId = 0; tokenId < tokens.length; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += PriceAware.getCurrentPriceInPeg(\n                token,\n                amounts[token],\n                forceCurBlock\n            );\n        }\n    }\n\n    /// @dev go through list of tokens and ammounts, summing up with interest\n    function sumTokensInPegWithYield(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts,\n        mapping(address => uint256) storage yieldQuotientsFP,\n        bool forceCurBlock\n    ) internal returns (uint256 totalPeg) {\n        for (uint256 tokenId = 0; tokenId < tokens.length; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += yieldTokenInPeg(\n                token,\n                amounts[token],\n                yieldQuotientsFP,\n                forceCurBlock\n            );\n        }\n    }\n\n    /// @dev calculate yield for token amount and convert to reference currency\n    function yieldTokenInPeg(\n        address token,\n        uint256 amount,\n        mapping(address => uint256) storage yieldQuotientsFP,\n        bool forceCurBlock\n    ) internal returns (uint256) {\n        uint256 yieldFP = Lending(lending()).viewBorrowingYieldFP(token);\n        // 1 * FP / FP = 1\n        uint256 amountInToken = (amount * yieldFP) / yieldQuotientsFP[token];\n        return\n            PriceAware.getCurrentPriceInPeg(\n                token,\n                amountInToken,\n                forceCurBlock\n            );\n    }\n\n    /// @dev move tokens from one holding to another\n    function adjustAmounts(\n        CrossMarginAccount storage account,\n        address fromToken,\n        address toToken,\n        uint256 soldAmount,\n        uint256 boughtAmount\n    ) internal {\n        account.holdings[fromToken] = account.holdings[fromToken] - soldAmount;\n        addHolding(account, toToken, boughtAmount);\n    }\n\n    /// sets borrow and holding to zero\n    function deleteAccount(CrossMarginAccount storage account) internal {\n        for (\n            uint256 borrowIdx = 0;\n            account.borrowTokens.length > borrowIdx;\n            borrowIdx++\n        ) {\n            address borrowToken = account.borrowTokens[borrowIdx];\n            totalShort[borrowToken] -= account.borrowed[borrowToken];\n            account.borrowed[borrowToken] = 0;\n            account.borrowedYieldQuotientsFP[borrowToken] = 0;\n        }\n        for (\n            uint256 holdingIdx = 0;\n            account.holdingTokens.length > holdingIdx;\n            holdingIdx++\n        ) {\n            address holdingToken = account.holdingTokens[holdingIdx];\n            totalLong[holdingToken] -= account.holdings[holdingToken];\n            account.holdings[holdingToken] = 0;\n            account.holdsToken[holdingToken] = false;\n        }\n        delete account.borrowTokens;\n        delete account.holdingTokens;\n    }\n\n    /// @dev minimum\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return b;\n        } else {\n            return a;\n        }\n    }\n}\n"
    },
    "contracts/PriceAware.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"./RoleAware.sol\";\nimport \"./MarginRouter.sol\";\n\n/// Stores how many of token you could get for 1k of peg\nstruct TokenPrice {\n    uint256 blockLastUpdated;\n    uint256 tokenPer1k;\n    address[] liquidationPath;\n    address[] inverseLiquidationPath;\n}\n\nabstract contract PriceAware is Ownable, RoleAware {\n    address public constant UNI = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address public peg;\n    mapping(address => TokenPrice) public tokenPrices;\n    /// update window in blocks\n    uint16 public priceUpdateWindow = 8;\n    uint256 public TEPID_UPDATE_RATE_PERMIL = 20;\n    uint256 public CONFIDENT_UPDATE_RATE_PERMIL = 650;\n    uint256 UPDATE_MAX_PEG_AMOUNT = 50_000;\n    uint256 UPDATE_MIN_PEG_AMOUNT = 1_000;\n\n    constructor(address _peg) Ownable() {\n        peg = _peg;\n    }\n\n    function setPriceUpdateWindow(uint16 window) external onlyOwner {\n        priceUpdateWindow = window;\n    }\n\n    function setTepidUpdateRate(uint256 rate) external onlyOwner {\n        TEPID_UPDATE_RATE_PERMIL = rate;\n    }\n\n    function setConfidentUpdateRate(uint256 rate) external onlyOwner {\n        CONFIDENT_UPDATE_RATE_PERMIL = rate;\n    }\n\n    function forcePriceUpdate(address token, uint256 inAmount)\n        public\n        returns (uint256)\n    {\n        return getUpdatedPriceInPeg(token, inAmount);\n    }\n\n    function setUpdateMaxPegAmount(uint256 amount) external onlyOwner {\n        UPDATE_MAX_PEG_AMOUNT = amount;\n    }\n\n    function setUpdateMinPegAmount(uint256 amount) external onlyOwner {\n        UPDATE_MIN_PEG_AMOUNT = amount;\n    }\n\n    function getCurrentPriceInPeg(\n        address token,\n        uint256 inAmount,\n        bool forceCurBlock\n    ) internal returns (uint256) {\n        TokenPrice storage tokenPrice = tokenPrices[token];\n        if (\n            block.number - tokenPrice.blockLastUpdated > priceUpdateWindow ||\n            (forceCurBlock && block.number != tokenPrice.blockLastUpdated) ||\n            tokenPrice.tokenPer1k == 0\n        ) {\n            return getUpdatedPriceInPeg(token, inAmount);\n        } else {\n            return (inAmount * 1000 ether) / tokenPrice.tokenPer1k;\n        }\n    }\n\n    function getUpdatedPriceInPeg(address token, uint256 inAmount)\n        internal\n        virtual\n        returns (uint256)\n    {\n        if (token == peg) {\n            return inAmount;\n        } else {\n            TokenPrice storage tokenPrice = tokenPrices[token];\n            uint256[] memory pathAmounts =\n                MarginRouter(router()).getAmountsOut(\n                    UNI,\n                    inAmount,\n                    tokenPrice.liquidationPath\n                );\n            uint256 outAmount = pathAmounts[pathAmounts.length - 1];\n\n            if (\n                outAmount > UPDATE_MIN_PEG_AMOUNT &&\n                outAmount < UPDATE_MAX_PEG_AMOUNT\n            ) {\n                confidentUpdatePriceInPeg(tokenPrice, inAmount, outAmount);\n            }\n\n            return outAmount;\n        }\n    }\n\n    // /// Do a tepid update of price coming from a potentially unreliable source\n    // function tepidUpdatePriceInPeg(\n    //     address token,\n    //     uint256 inAmount,\n    //     uint256 outAmount\n    // ) internal {\n    //     _updatePriceInPeg(\n    //         tokenPrices[token],\n    //         inAmount,\n    //         outAmount,\n    //         TEPID_UPDATE_RATE_PERMIL\n    //     );\n    // }\n\n    function confidentUpdatePriceInPeg(\n        TokenPrice storage tokenPrice,\n        uint256 inAmount,\n        uint256 outAmount\n    ) internal {\n        _updatePriceInPeg(\n            tokenPrice,\n            inAmount,\n            outAmount,\n            CONFIDENT_UPDATE_RATE_PERMIL\n        );\n        tokenPrice.blockLastUpdated = block.number;\n    }\n\n    function _updatePriceInPeg(\n        TokenPrice storage tokenPrice,\n        uint256 inAmount,\n        uint256 outAmount,\n        uint256 weightPerMil\n    ) internal {\n        uint256 updatePer1k = (1000 ether * inAmount) / (outAmount + 1);\n        tokenPrice.tokenPer1k =\n            (tokenPrice.tokenPer1k *\n                (1000 - weightPerMil) +\n                updatePer1k *\n                weightPerMil) /\n            1000;\n    }\n\n    // add path from token to current liquidation peg\n    function setLiquidationPath(address[] memory path) external {\n        require(\n            isTokenActivator(msg.sender),\n            \"not authorized to set lending cap\"\n        );\n        address token = path[0];\n        tokenPrices[token].liquidationPath = new address[](path.length);\n        tokenPrices[token].inverseLiquidationPath = new address[](path.length);\n\n        for (uint16 i = 0; path.length > i; i++) {\n            tokenPrices[token].liquidationPath[i] = path[i];\n            tokenPrices[token].inverseLiquidationPath[i] = path[\n                path.length - i - 1\n            ];\n        }\n        uint256[] memory pathAmounts =\n            MarginRouter(router()).getAmountsIn(UNI, 1000 ether, path);\n        uint256 inAmount = pathAmounts[0];\n        _updatePriceInPeg(tokenPrices[token], inAmount, 1000 ether, 1000);\n    }\n\n    function liquidateToPeg(address token, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        if (token == peg) {\n            return amount;\n        } else {\n            TokenPrice storage tP = tokenPrices[token];\n            uint256[] memory amounts =\n                MarginRouter(router()).authorizedSwapExactT4T(\n                    UNI,\n                    amount,\n                    0,\n                    tP.liquidationPath\n                );\n\n            uint256 outAmount = amounts[amounts.length - 1];\n            confidentUpdatePriceInPeg(tP, amount, outAmount);\n\n            return outAmount;\n        }\n    }\n\n    function liquidateFromPeg(address token, uint256 targetAmount)\n        internal\n        returns (uint256)\n    {\n        if (token == peg) {\n            return targetAmount;\n        } else {\n            TokenPrice storage tP = tokenPrices[token];\n            uint256[] memory amounts =\n                MarginRouter(router()).authorizedSwapT4ExactT(\n                    UNI,\n                    targetAmount,\n                    type(uint256).max,\n                    tP.inverseLiquidationPath\n                );\n\n            confidentUpdatePriceInPeg(tP, targetAmount, amounts[0]);\n\n            return amounts[0];\n        }\n    }\n}\n"
    },
    "contracts/TokenAdmin.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"./RoleAware.sol\";\nimport \"./IncentiveDistribution.sol\";\nimport \"./Fund.sol\";\nimport \"./CrossMarginTrading.sol\";\nimport \"./MarginRouter.sol\";\nimport \"../interfaces/IDelegateOwner.sol\";\n\ncontract TokenAdmin is RoleAware, Ownable, IDelegateOwner {\n    uint256 public totalLendingTargetPortion;\n    uint256 public totalBorrowingTargetPortion;\n    address[] public incentiveTokens;\n    mapping(address => uint256) public tokenWeights;\n    uint256 public totalTokenWeights;\n    mapping(address => uint8) public tokenLendingTranches;\n    mapping(address => uint8) public tokenBorrowingTranches;\n    uint8 public nextTrancheIndex = 20;\n\n    uint256 public initHourlyYieldAPRPercent = 10;\n\n    // TODO give this contract ownership of incentive distribution\n    // during deploy after everything else is incentivized\n    constructor(\n        uint256 lendingTargetPortion,\n        uint256 borrowingTargetPortion,\n        address _roles\n    ) RoleAware(_roles) Ownable() {\n        totalLendingTargetPortion = lendingTargetPortion;\n        totalBorrowingTargetPortion = borrowingTargetPortion;\n    }\n\n    function activateToken(\n        address token,\n        uint256 exposureCap,\n        uint256 lendingBuffer,\n        uint256 incentiveWeight,\n        address[] memory liquidationPath\n    ) external onlyOwner {\n        require(!Fund(fund()).activeTokens(token), \"Token already is active\");\n\n        Fund(fund()).activateToken(token);\n        CrossMarginTrading(marginTrading()).setTokenCap(token, exposureCap);\n        Lending(lending()).setLendingCap(token, exposureCap);\n        Lending(lending()).setLendingBuffer(token, lendingBuffer);\n        Lending(lending()).setHourlyYieldAPR(token, initHourlyYieldAPRPercent);\n        Lending(lending()).initBorrowYieldAccumulator(token);\n\n        if (incentiveWeight > 0) {\n            totalTokenWeights += incentiveWeight;\n            tokenWeights[token] = incentiveWeight;\n            IncentiveDistribution iD =\n                IncentiveDistribution(incentiveDistributor());\n\n            // init lending\n            uint256 lendingShare =\n                calcTrancheShare(incentiveWeight, totalLendingTargetPortion);\n            iD.initTranche(nextTrancheIndex, lendingShare);\n            tokenLendingTranches[token] = nextTrancheIndex;\n            Lending(lending()).setIncentiveTranche(token, nextTrancheIndex);\n            nextTrancheIndex++;\n\n            // init borrowing\n            uint256 borrowingShare =\n                calcTrancheShare(incentiveWeight, totalBorrowingTargetPortion);\n            iD.initTranche(nextTrancheIndex, borrowingShare);\n            tokenBorrowingTranches[token] = nextTrancheIndex;\n            MarginRouter(router()).setIncentiveTranche(token, nextTrancheIndex);\n            nextTrancheIndex++;\n\n            updateIncentiveShares(iD);\n            incentiveTokens.push(token);\n\n            require(\n                liquidationPath[0] == token &&\n                    liquidationPath[liquidationPath.length - 1] ==\n                    CrossMarginTrading(marginTrading()).peg(),\n                \"Invalid liquidationPath -- should go from token to peg\"\n            );\n            CrossMarginTrading(marginTrading()).setLiquidationPath(\n                liquidationPath\n            );\n        }\n    }\n\n    function changeTokenCap(address token, uint256 exposureCap)\n        external\n        onlyOwner\n    {\n        Lending(lending()).setLendingCap(token, exposureCap);\n        CrossMarginTrading(marginTrading()).setTokenCap(token, exposureCap);\n    }\n\n    function changeTokenIncentiveWeight(address token, uint256 tokenWeight)\n        external\n        onlyOwner\n    {\n        totalTokenWeights =\n            totalTokenWeights +\n            tokenWeight -\n            tokenWeights[token];\n        tokenWeights[token] = tokenWeight;\n\n        updateIncentiveShares(IncentiveDistribution(incentiveDistributor()));\n    }\n\n    function changeLendingBuffer(address token, uint256 lendingBuffer)\n        external\n        onlyOwner\n    {\n        Lending(lending()).setLendingBuffer(token, lendingBuffer);\n    }\n\n    //function changeBondLendingWeights(address token, uint256[] memory weights) external onlyOwner {\n    //    Lending(lending()).setRuntimeWeights(token, weights);\n    //}\n\n    function updateIncentiveShares(IncentiveDistribution iD) internal {\n        for (uint8 i = 0; incentiveTokens.length > i; i++) {\n            address incentiveToken = incentiveTokens[i];\n            uint256 tokenWeight = tokenWeights[incentiveToken];\n            uint256 lendingShare =\n                calcTrancheShare(tokenWeight, totalLendingTargetPortion);\n            iD.setTrancheShare(\n                tokenLendingTranches[incentiveToken],\n                lendingShare\n            );\n\n            uint256 borrowingShare =\n                calcTrancheShare(tokenWeight, totalBorrowingTargetPortion);\n            iD.setTrancheShare(\n                tokenBorrowingTranches[incentiveToken],\n                borrowingShare\n            );\n        }\n    }\n\n    function calcTrancheShare(uint256 incentiveWeight, uint256 targetPortion)\n        internal\n        view\n        returns (uint256)\n    {\n        return (incentiveWeight * targetPortion) / totalTokenWeights;\n    }\n\n    function setLendingTargetPortion(uint256 portion) external onlyOwner {\n        totalLendingTargetPortion = portion;\n    }\n\n    function setBorrowingTargetPortion(uint256 portion) external onlyOwner {\n        totalBorrowingTargetPortion = portion;\n    }\n\n    function changeHourlyYieldAPR(address token, uint256 aprPercent)\n        external\n        onlyOwner\n    {\n        Lending(lending()).setHourlyYieldAPR(token, aprPercent);\n    }\n\n    function setInitHourlyYieldAPR(uint256 value) external onlyOwner {\n        initHourlyYieldAPRPercent = value;\n    }\n\n    function relinquishOwnership(address property, address newOwner)\n        external\n        override\n        onlyOwner\n    {\n        Ownable(property).transferOwnership(newOwner);\n    }\n}\n"
    },
    "interfaces/IDelegateOwner.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\ninterface IDelegateOwner {\n    function relinquishOwnership(address property, address newOwner) external;\n}\n"
    },
    "contracts/DependencyController.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"./RoleAware.sol\";\nimport \"../interfaces/IExecutor.sol\";\nimport \"../interfaces/IDelegateOwner.sol\";\n\ncontract DependencyController is RoleAware, Ownable, IDelegateOwner {\n    constructor(address _roles) RoleAware(_roles) Ownable() {}\n\n    address[] public managedContracts;\n    mapping(uint16 => bool) public knownCharacters;\n    mapping(uint16 => bool) public knownRoles;\n    mapping(address => address) public delegateOwner;\n    mapping(address => bool) public disabler;\n    address public currentExecutor = address(0);\n\n    uint16[] public allCharacters;\n    uint16[] public allRoles;\n\n    modifier onlyOwnerOrExecOrDisabler() {\n        require(\n            owner() == _msgSender() ||\n                disabler[_msgSender()] ||\n                currentExecutor == _msgSender(),\n            \"Caller is not the owner or authorized disabler or executor\"\n        );\n        _;\n    }\n\n    modifier onlyOwnerOrExec() {\n        require(\n            owner() == _msgSender() || currentExecutor == _msgSender(),\n            \"Caller is not the owner or executor\"\n        );\n        _;\n    }\n\n    function verifyOwnership() external view returns (bool ownsAll) {\n        ownsAll = ownsContractStrict(address(roles));\n        for (uint256 i = 0; managedContracts.length > i; i++) {\n            address contr = managedContracts[i];\n            ownsAll = ownsAll && ownsContract(contr);\n        }\n    }\n\n    function verifyOwnershipStrict() external view returns (bool ownsAll) {\n        ownsAll = ownsContractStrict(address(roles));\n        for (uint256 i = 0; managedContracts.length > i; i++) {\n            address contr = managedContracts[i];\n            ownsAll = ownsAll && ownsContractStrict(contr);\n        }\n    }\n\n    function ownsContract(address contr) public view returns (bool) {\n        address contrOwner = Ownable(contr).owner();\n        return\n            contrOwner == address(this) ||\n            contrOwner == owner() ||\n            contrOwner == delegateOwner[contr];\n    }\n\n    function ownsContractStrict(address contr) public view returns (bool) {\n        address contrOwner = Ownable(contr).owner();\n        return\n            contrOwner == address(this) ||\n            (contrOwner == delegateOwner[contr] &&\n                Ownable(delegateOwner[contr]).owner() == address(this));\n    }\n\n    function relinquishOwnership(address ownableContract, address newOwner)\n        external\n        override\n        onlyOwnerOrExec\n    {\n        Ownable(ownableContract).transferOwnership(newOwner);\n    }\n\n    function setDisabler(address disablerAddress, bool authorized)\n        external\n        onlyOwnerOrExec\n    {\n        disabler[disablerAddress] = authorized;\n    }\n\n    function executeAsOwner(address executor) external onlyOwnerOrExec {\n        address[] memory properties = IExecutor(executor).requiredProperties();\n        for (uint256 i = 0; properties.length > i; i++) {\n            address property = properties[i];\n            if (delegateOwner[property] != address(0)) {\n                IDelegateOwner(delegateOwner[property]).relinquishOwnership(\n                    property,\n                    executor\n                );\n            } else {\n                Ownable(property).transferOwnership(executor);\n            }\n        }\n\n        uint16[] memory requiredRoles = IExecutor(executor).requiredRoles();\n\n        for (uint256 i = 0; requiredRoles.length > i; i++) {\n            _giveRole(requiredRoles[i], executor);\n        }\n\n        currentExecutor = executor;\n        IExecutor(executor).execute();\n        currentExecutor = address(0);\n\n        address rightfulOwner = IExecutor(executor).rightfulOwner();\n        require(\n            rightfulOwner == address(this) || rightfulOwner == owner(),\n            \"Executor doesn't have the right rightful owner\"\n        );\n\n        for (uint256 i = 0; properties.length > i; i++) {\n            address property = properties[i];\n            require(\n                Ownable(property).owner() == rightfulOwner,\n                \"Executor did not return ownership\"\n            );\n            if (delegateOwner[property] != address(0)) {\n                Ownable(property).transferOwnership(delegateOwner[property]);\n            }\n        }\n\n        for (uint256 i = 0; requiredRoles.length > i; i++) {\n            _removeRole(requiredRoles[i], executor);\n        }\n    }\n\n    function manageContract(\n        address contr,\n        uint16[] memory charactersPlayed,\n        uint16[] memory rolesPlayed,\n        address[] memory ownsAsDelegate\n    ) external onlyOwnerOrExec {\n        managedContracts.push(contr);\n\n        // set up all characters this contract plays\n        for (uint256 i = 0; charactersPlayed.length > i; i++) {\n            uint16 character = charactersPlayed[i];\n            _setMainCharacter(character, contr);\n        }\n\n        // all roles this contract plays\n        for (uint256 i = 0; rolesPlayed.length > i; i++) {\n            uint16 role = rolesPlayed[i];\n            _giveRole(role, contr);\n        }\n\n        // update this contract with all characters we know about\n        for (uint256 i = 0; allCharacters.length > i; i++) {\n            RoleAware(contr).updateMainCharacterCache(allCharacters[i]);\n        }\n\n        // update this contract with all roles for all contracts we know about\n        for (uint256 i = 0; allRoles.length > i; i++) {\n            for (uint256 j = 0; managedContracts.length > i; i++) {\n                RoleAware(contr).updateRoleCache(\n                    allRoles[i],\n                    managedContracts[j]\n                );\n            }\n        }\n\n        for (uint256 i = 0; ownsAsDelegate.length > i; i++) {\n            Ownable(ownsAsDelegate[i]).transferOwnership(contr);\n            delegateOwner[ownsAsDelegate[i]] = contr;\n        }\n    }\n\n    function disableContract(address contr) external onlyOwnerOrExecOrDisabler {\n        _disableContract(contr);\n    }\n\n    function _disableContract(address contr) internal {\n        for (uint256 i = 0; allRoles.length > i; i++) {\n            if (roles.getRole(allRoles[i], contr)) {\n                _removeRole(allRoles[i], contr);\n            }\n        }\n\n        for (uint256 i = 0; allCharacters.length > i; i++) {\n            if (roles.mainCharacters(allCharacters[i]) == contr) {\n                _setMainCharacter(allCharacters[i], address(0));\n            }\n        }\n    }\n\n    function giveRole(uint16 role, address actor) external onlyOwnerOrExec {\n        _giveRole(role, actor);\n    }\n\n    function removeRole(uint16 role, address actor)\n        external\n        onlyOwnerOrExecOrDisabler\n    {\n        _removeRole(role, actor);\n    }\n\n    function _removeRole(uint16 role, address actor) internal {\n        roles.removeRole(role, actor);\n        updateRoleCache(role, actor);\n    }\n\n    function setMainCharacter(uint16 role, address actor)\n        external\n        onlyOwnerOrExec\n    {\n        _setMainCharacter(role, actor);\n    }\n\n    function _giveRole(uint16 role, address actor) internal {\n        if (!knownRoles[role]) {\n            knownRoles[role] = true;\n            allRoles.push(role);\n        }\n        roles.giveRole(role, actor);\n        updateRoleCache(role, actor);\n    }\n\n    function _setMainCharacter(uint16 character, address actor) internal {\n        if (!knownCharacters[character]) {\n            knownCharacters[character] = true;\n            allCharacters.push(character);\n        }\n        roles.setMainCharacter(character, actor);\n        updateMainCharacterCache(character);\n    }\n\n    function updateMainCharacterCache(uint16 character) public override {\n        for (uint256 i = 0; managedContracts.length > i; i++) {\n            RoleAware(managedContracts[i]).updateMainCharacterCache(character);\n        }\n    }\n\n    function updateRoleCache(uint16 role, address contr) public override {\n        for (uint256 i = 0; managedContracts.length > i; i++) {\n            RoleAware(managedContracts[i]).updateRoleCache(role, contr);\n        }\n    }\n}\n"
    },
    "interfaces/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\ninterface IExecutor {\n    function rightfulOwner() external returns (address);\n\n    function execute() external;\n\n    function requiredProperties() external returns (address[] memory);\n\n    function requiredRoles() external returns (uint16[] memory);\n}\n"
    },
    "contracts/tests/LiquidityMiningRewardTest.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"../LiquidityMiningReward.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\nimport \"../Roles.sol\";\nimport \"../Fund.sol\";\nimport \"../IncentiveDistribution.sol\";\n\ncontract LiquidityMiningRewardTest {\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint16 public constant WITHDRAWER = 1;\n    uint16 public constant MARGIN_CALLER = 2;\n    uint16 public constant BORROWER = 3;\n    uint16 public constant MARGIN_TRADER = 4;\n    uint16 public constant FEE_SOURCE = 5;\n    uint16 public constant LIQUIDATOR = 6;\n    uint16 public constant AUTHORIZED_FUND_TRADER = 7;\n    uint16 public constant INCENTIVE_REPORTER = 8;\n    uint16 public constant TOKEN_ACTIVATOR = 9;\n\n    uint16 public constant FUND = 101;\n    uint16 public constant LENDING = 102;\n    uint16 public constant ROUTER = 103;\n    uint16 public constant MARGIN_TRADING = 104;\n    uint16 public constant FEE_CONTROLLER = 105;\n    uint16 public constant PRICE_CONTROLLER = 106;\n\n    ERC20PresetMinterPauser stakeToken;\n    ERC20PresetMinterPauser rewardToken;\n    LiquidityMiningReward liqui;\n    IncentiveDistribution incentiveDistro;\n\n    constructor() {\n        // deploy roles\n        Roles roles = new Roles();\n        Fund fund = new Fund(WETH, address(roles));\n        roles.setMainCharacter(FUND, address(fund));\n\n        rewardToken = new ERC20PresetMinterPauser(\"Reward Token\", \"REW\");\n        rewardToken.mint(address(fund), 100_000 ether);\n        fund.activateToken(address(rewardToken));\n\n        incentiveDistro = new IncentiveDistribution(\n            address(rewardToken),\n            4_000,\n            address(roles)\n        );\n        roles.giveRole(WITHDRAWER, address(incentiveDistro));\n        incentiveDistro.initTranche(0, 200);\n\n        stakeToken = new ERC20PresetMinterPauser(\"Stake Token\", \"STK\");\n        stakeToken.mint(address(this), 20_000 ether);\n\n        liqui = new LiquidityMiningReward(\n            address(incentiveDistro),\n            address(stakeToken),\n            block.timestamp - 1\n        );\n\n        roles.giveRole(INCENTIVE_REPORTER, address(liqui));\n    }\n\n    function stake(uint256 amount) public returns (uint256 stakeBalance) {\n        stakeToken.approve(address(liqui), amount * (1 ether));\n        liqui.depositStake(amount * (1 ether));\n        stakeBalance = stakeToken.balanceOf(address(this));\n        require(\n            liqui.stakeAmounts(address(this)) == amount * (1 ether),\n            \"Incorrect stake amount\"\n        );\n    }\n\n    function withdrawStake(uint256 amount)\n        public\n        returns (uint256 stakeBalance, uint256 incentiveBalance)\n    {\n        liqui.withdrawStake(amount * (1 ether));\n        stakeBalance = stakeToken.balanceOf(address(this));\n        incentiveBalance = rewardToken.balanceOf(address(this));\n    }\n\n    function withdrawReward(uint256 expectedReward)\n        public\n        returns (uint256 stakeBalance, uint256 incentiveBalance)\n    {\n        uint256 initialIncentiveBalance = rewardToken.balanceOf(address(this));\n        liqui.withdrawReward();\n        stakeBalance = stakeToken.balanceOf(address(this));\n        incentiveBalance = rewardToken.balanceOf(address(this));\n        uint256 incentiveBalanceDiff =\n            incentiveBalance - initialIncentiveBalance;\n        require(\n            incentiveBalanceDiff > expectedReward * 1 ether,\n            \"Reward did not grow enough\"\n        );\n    }\n\n    function stakeAmount() public view returns (uint256 amount) {\n        amount = liqui.stakeAmounts(address(this));\n    }\n\n    function updateReward() public {\n        incentiveDistro.forcePeriodTotalUpdate(0);\n    }\n\n    function rewardBalance() public view returns (uint24 balance) {\n        balance = uint24(incentiveDistro.viewRewardAmount(0, 1) / (1 ether));\n    }\n}\n// jump ahead 1 period,2 periods, 4 periods and then 2 days\n"
    },
    "contracts/LiquidityMiningReward.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IncentiveDistribution.sol\";\n\ncontract LiquidityMiningReward is Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public stakeToken;\n    mapping(address => uint256) public claimIds;\n    mapping(address => uint256) public stakeAmounts;\n    IncentiveDistribution incentiveDistributor;\n    uint256 public incentiveStart;\n\n    constructor(\n        address _incentiveDistributor,\n        address _stakeToken,\n        uint256 startTimestamp\n    ) {\n        incentiveDistributor = IncentiveDistribution(_incentiveDistributor);\n        stakeToken = IERC20(_stakeToken);\n        incentiveStart = startTimestamp;\n    }\n\n    function migrateIncentiveDistributor(address newDistributor)\n        external\n        onlyOwner\n    {\n        incentiveDistributor = IncentiveDistribution(newDistributor);\n    }\n\n    function depositStake(uint256 amount) external {\n        require(\n            block.timestamp > incentiveStart,\n            \"Incentive hasn't started yet\"\n        );\n\n        stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        if (claimIds[msg.sender] > 0) {\n            incentiveDistributor.addToClaimAmount(\n                0,\n                claimIds[msg.sender],\n                amount\n            );\n        } else {\n            uint256 claimId =\n                incentiveDistributor.startClaim(0, msg.sender, amount);\n            claimIds[msg.sender] = claimId;\n            require(claimId > 0, \"Distribution is over or paused\");\n        }\n\n        stakeAmounts[msg.sender] += amount;\n    }\n\n    function withdrawStake(uint256 amount) external {\n        uint256 stakeAmount = stakeAmounts[msg.sender];\n        require(stakeAmount >= amount, \"Not enough stake to withdraw\");\n\n        stakeToken.safeTransfer(msg.sender, amount);\n        stakeAmounts[msg.sender] = stakeAmount - amount;\n\n        if (stakeAmount == amount) {\n            incentiveDistributor.endClaim(0, claimIds[msg.sender]);\n            claimIds[msg.sender] = 0;\n        } else {\n            incentiveDistributor.subtractFromClaimAmount(\n                0,\n                claimIds[msg.sender],\n                amount\n            );\n        }\n    }\n\n    function withdrawReward() external returns (uint256) {\n        uint256 claimId = claimIds[msg.sender];\n        require(claimId > 0, \"No registered claim\");\n        return incentiveDistributor.withdrawReward(0, claimId);\n    }\n}\n\n// USDC - MFI pair token\n// 0x9d640080af7c81911d87632a7d09cc4ab6b133ac\n\n// on ropsten:\n// 0xc4c79A0e1C7A9c79f1e943E3a5bEc65396a5434a\n"
    },
    "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overloaded;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        _approve(account, _msgSender(), currentAllowance - amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping (bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {grantRole} to track enumerable memberships\n     */\n    function grantRole(bytes32 role, address account) public virtual override {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     */\n    function revokeRole(bytes32 role, address account) public virtual override {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     */\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/tests/CrossMarginTradingTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\npragma solidity ^0.8.0;\n\nimport \"../CrossMarginTrading.sol\";\n\naddress constant TEST_PEG = 0x0000000000000000000000000000000000000010;\naddress constant TRADER_ONE = 0x0000000000000000000000000000000000000001;\n\ncontract CrossMarginTradingTest is CrossMarginTrading {\n    constructor(address _roles) CrossMarginTrading(TEST_PEG, _roles) {\n        coolingOffPeriod = 0;\n    }\n\n    function getUpdatedPriceInPeg(address token, uint256 inAmount)\n        internal\n        override\n        returns (uint256)\n    {\n        if (inAmount > 0) {\n            confidentUpdatePriceInPeg(tokenPrices[token], inAmount, inAmount);\n        }\n        return inAmount;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}